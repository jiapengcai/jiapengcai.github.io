<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/posts/63105/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单</p>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong><br />
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<span id="more"></span>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>约束条件</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></li>
<li>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></li>
<li>数组里每个元素除了那个只出现一次的元素，其它元素都会出现两次。</li>
</ul>
<p><strong>解法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/single-number">https://leetcode.cn/problems/single-number</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>175. 组合两个表</title>
    <url>/posts/55850/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单<br />
编写一个SQL查询来报告 Person 表中每个人的姓、名、城市和州。如果 personId 的地址不在 Address 表中，则报告为空  null 。<br />
以<strong>任意顺序</strong>返回结果表。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (personId <span class="type">int</span>, firstName <span class="type">varchar</span>(<span class="number">255</span>), lastName <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Address (addressId <span class="type">int</span>, personId <span class="type">int</span>, city <span class="type">varchar</span>(<span class="number">255</span>), state <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Address</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Leetcode&#x27;</span>, <span class="string">&#x27;California&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表: Person</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 列名         <span class="operator">|</span> 类型     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> PersonId    <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> FirstName   <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> LastName    <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">personId 是该表的主键列。</span><br><span class="line">该表包含一些人的 ID 和他们的姓和名的信息。</span><br></pre></td></tr></table></figure>
<p>表: Address</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 列名         <span class="operator">|</span> 类型    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> AddressId   <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> PersonId    <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> City        <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> State       <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">addressId 是该表的主键列。</span><br><span class="line">该表的每一行都包含一个 ID <span class="operator">=</span> PersonId 的人的城市和州的信息。</span><br></pre></td></tr></table></figure>
<p>查询结果格式如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Person表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> personId <span class="operator">|</span> lastName <span class="operator">|</span> firstName <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>        <span class="operator">|</span> Wang     <span class="operator">|</span> Allen     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> Alice    <span class="operator">|</span> Bob       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+-----------+</span></span><br><span class="line">Address表:</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+------------+</span></span><br><span class="line"><span class="operator">|</span> addressId <span class="operator">|</span> personId <span class="operator">|</span> city          <span class="operator">|</span> state      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>         <span class="operator">|</span> <span class="number">2</span>        <span class="operator">|</span> <span class="keyword">New</span> York City <span class="operator">|</span> <span class="keyword">New</span> York   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>         <span class="operator">|</span> <span class="number">3</span>        <span class="operator">|</span> Leetcode      <span class="operator">|</span> California <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+------------+</span></span><br><span class="line">输出: </span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+----------+</span></span><br><span class="line"><span class="operator">|</span> firstName <span class="operator">|</span> lastName <span class="operator">|</span> city          <span class="operator">|</span> state    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Allen     <span class="operator">|</span> Wang     <span class="operator">|</span> <span class="keyword">Null</span>          <span class="operator">|</span> <span class="keyword">Null</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Bob       <span class="operator">|</span> Alice    <span class="operator">|</span> <span class="keyword">New</span> York City <span class="operator">|</span> <span class="keyword">New</span> York <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+----------+---------------+----------+</span></span><br><span class="line">解释: </span><br><span class="line">地址表中没有 personId <span class="operator">=</span> <span class="number">1</span> 的地址，所以它们的城市和州返回 <span class="keyword">null</span>。</span><br><span class="line">addressId <span class="operator">=</span> <span class="number">1</span> 包含了 personId <span class="operator">=</span> <span class="number">2</span> 的地址信息。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.FirstName, a.LastName, b.City, b.State</span><br><span class="line"><span class="keyword">FROM</span> Person <span class="keyword">AS</span> a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.PersonId <span class="operator">=</span> b.PersonId</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/combine-two-tables">https://leetcode.cn/problems/combine-two-tables</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>176. 第二高的薪水</title>
    <url>/posts/23560/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 中等<br />
编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null 。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (id <span class="type">int</span>, salary <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;300&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表: Employee</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary      <span class="operator">|</span> <span class="type">int</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line">id 是这个表的主键。</span><br><span class="line">表的每一行包含员工的工资信息。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employee 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">100</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">200</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">300</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> SecondHighestSalary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">200</span>                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employee 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">100</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> SecondHighestSalary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">null</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(Salary) SecondHighestSalary</span><br><span class="line"><span class="keyword">FROM</span> Employee</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="built_in">max</span>(Salary) <span class="keyword">FROM</span> Employee)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/second-highest-salary">https://leetcode.cn/problems/second-highest-salary</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>178. 分数排名</title>
    <url>/posts/32576/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 中等<br />
编写 SQL 查询对分数进行排序。排名按以下规则计算:</p>
<ul>
<li>分数应按从高到低排列。</li>
<li>如果两个分数相等，那么两个分数的排名应该相同。</li>
<li>在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。<br />
按 <em><strong>score</strong></em> 降序返回结果表。</li>
</ul>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Scores (id <span class="type">int</span>, score <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Scores</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3.5&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3.85&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表：Scores</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> score       <span class="operator">|</span> <span class="type">decimal</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">Id是该表的主键。</span><br><span class="line">该表的每一行都包含了一场比赛的分数。Score是一个有两位小数点的浮点值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Scores 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">3.50</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">3.85</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span>  <span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line">输出: </span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br><span class="line"><span class="operator">|</span> score <span class="operator">|</span> rank <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4.00</span>  <span class="operator">|</span> <span class="number">1</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.85</span>  <span class="operator">|</span> <span class="number">2</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.65</span>  <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3.50</span>  <span class="operator">|</span> <span class="number">4</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+</span></span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  Score,</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">   <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Score s</span><br><span class="line">         <span class="keyword">FROM</span> Scores) tmp</span><br><span class="line">   <span class="keyword">WHERE</span> s <span class="operator">&gt;=</span> Score) Rank</span><br><span class="line"><span class="keyword">FROM</span> Scores</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/rank-scores">https://leetcode.cn/problems/rank-scores</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>180. 连续出现的数字</title>
    <url>/posts/41601/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 中等<br />
编写一个 SQL 查询，查找所有至少连续出现三次的数字。<br />
返回的结果表中的数据可以按<strong>任意顺序</strong>排列。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Logs (id <span class="type">int</span>, num <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Logs</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Logs (id, num) <span class="keyword">values</span> (<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表：Logs</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> num         <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">id 是这个表的主键。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Logs 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> Num <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> <span class="number">1</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">6</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">7</span>  <span class="operator">|</span> <span class="number">2</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">Result</span> 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> ConsecutiveNums <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line">解释：<span class="number">1</span> 是唯一连续出现至少三次的数字。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> l1.Num <span class="keyword">AS</span> ConsecutiveNums</span><br><span class="line"><span class="keyword">FROM</span> logs l1, logs l2, logs l3</span><br><span class="line"><span class="keyword">WHERE</span> l1.Id <span class="operator">=</span> l2.Id <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">AND</span> l2.Id <span class="operator">=</span> l3.Id <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">AND</span> l1.Num <span class="operator">=</span> l2.Num</span><br><span class="line">      <span class="keyword">AND</span> l2.Num <span class="operator">=</span> l3.Num;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/consecutive-numbers">https://leetcode.cn/problems/consecutive-numbers</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>181. 超过经理收入的员工</title>
    <url>/posts/58200/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单<br />
编写一个SQL查询来查找收入比经理高的员工。<br />
以<strong>任意顺序</strong>返回结果表。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">255</span>), salary <span class="type">int</span>, managerId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, managerId) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;70000&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, managerId) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>, <span class="string">&#x27;80000&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, managerId) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;60000&#x27;</span>, <span class="string">&#x27;None&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, managerId) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;90000&#x27;</span>, <span class="string">&#x27;None&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表：Employee</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name        <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary      <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> managerId   <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">Id是该表的主键。</span><br><span class="line">该表的每一行都表示雇员的ID、姓名、工资和经理的ID。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Employee 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span> salary <span class="operator">|</span> managerId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Joe   <span class="operator">|</span> <span class="number">70000</span>  <span class="operator">|</span> <span class="number">3</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Henry <span class="operator">|</span> <span class="number">80000</span>  <span class="operator">|</span> <span class="number">4</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> Sam   <span class="operator">|</span> <span class="number">60000</span>  <span class="operator">|</span> <span class="keyword">Null</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> Max   <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span> <span class="keyword">Null</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+-----------+</span></span><br><span class="line">输出: </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> Employee <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> Joe      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line">解释: Joe 是唯一挣得比经理多的雇员。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.Name <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">AS</span> a, Employee <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.Salary <span class="operator">&gt;</span> b.Salary</span><br><span class="line"><span class="keyword">AND</span> a.ManagerId <span class="operator">=</span> b.Id</span><br><span class="line"><span class="keyword">AND</span> a.ManagerId <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/employees-earning-more-than-their-managers">https://leetcode.cn/problems/employees-earning-more-than-their-managers</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>182. 查找重复的电子邮箱</title>
    <url>/posts/13020/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单<br />
编写一个 SQL 查询，查找 <em><strong>Person</strong></em> 表中所有重复的电子邮箱。<br />
返回的结果表中的数据可以按<strong>任意顺序</strong>排列。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (id <span class="type">int</span>, email <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a@b.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c@d.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;a@b.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表：Person</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> email       <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">id 是这个表的主键。   </span><br><span class="line">表的每一行都包含一个邮箱地址。邮箱地址不包含大写字母。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Person 表：</span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> email   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> a<span class="variable">@b</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> c<span class="variable">@d</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> a<span class="variable">@b</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+---------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> Email   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line"><span class="operator">|</span> a<span class="variable">@b</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+</span></span><br><span class="line">解释：a<span class="variable">@b</span>.com重复了两次</span><br></pre></td></tr></table></figure>
<p><strong>解法1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Email</span><br><span class="line"><span class="keyword">FROM</span> Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Email</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>解法2：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> a.Email</span><br><span class="line"><span class="keyword">FROM</span> Person <span class="keyword">AS</span> a, Person <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">WHERE</span> a.id <span class="operator">!=</span> b.id</span><br><span class="line"><span class="keyword">AND</span> a.Email<span class="operator">=</span>b.Email</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/duplicate-emails">https://leetcode.cn/problems/duplicate-emails</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>183. 从不订购的客户</title>
    <url>/posts/44608/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单<br />
某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。<br />
返回的结果表中的数据可以按<strong>任意顺序</strong>排列。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Customers (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Orders (id <span class="type">int</span>, customerId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Customers</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (id, name) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (id, name) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (id, name) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Customers (id, name) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Max&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Orders (id, customerId) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Orders (id, customerId) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表：Customers</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name        <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">id 是这个表的主键。</span><br><span class="line">表的每一行表示一个用户的ID和名字</span><br></pre></td></tr></table></figure>
<p>表：Orders</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Column</span> Name <span class="operator">|</span> Type <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> customerId  <span class="operator">|</span> <span class="type">int</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+------+</span></span><br><span class="line">id 是这个表的主键。</span><br><span class="line">customerId是来自Customers表的外键</span><br><span class="line">表的每一行表示一个订单的ID以及下订单的用户的ID</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Customers 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Joe   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Henry <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> Sam   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> Max   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line">Orders 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> customerId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> <span class="number">3</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> <span class="number">1</span>          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------+</span></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> Customers <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> Henry     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Max       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br></pre></td></tr></table></figure>
<p><strong>解法1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.Name <span class="keyword">AS</span> Customers </span><br><span class="line"><span class="keyword">FROM</span> Customers c <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders o </span><br><span class="line"><span class="keyword">ON</span> c.Id<span class="operator">=</span>o.CustomerId </span><br><span class="line"><span class="keyword">WHERE</span> o.CustomerId <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p><strong>解法2：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Orders <span class="keyword">AS</span> b</span><br><span class="line">  <span class="keyword">WHERE</span> a.Id <span class="operator">=</span> b.CustomerId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/customers-who-never-order">https://leetcode.cn/problems/customers-who-never-order</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>184. 部门工资最高的员工</title>
    <url>/posts/49748/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 中等<br />
编写SQL查询以查找每个部门中薪资最高的员工。<br />
按<strong>任意顺序</strong>返回结果表。</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">255</span>), salary <span class="type">int</span>, departmentId <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Department (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, departmentId) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>, <span class="string">&#x27;70000&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, departmentId) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;90000&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, departmentId) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Henry&#x27;</span>, <span class="string">&#x27;80000&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, departmentId) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;60000&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, name, salary, departmentId) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;Max&#x27;</span>, <span class="string">&#x27;90000&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Department</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Department (id, name) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;IT&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Department (id, name) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Sales&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>表： Employee</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 列名          <span class="operator">|</span> 类型    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id           <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name         <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> salary       <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> departmentId <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+---------+</span></span><br><span class="line">id是此表的主键列。</span><br><span class="line">departmentId是Department表中ID的外键。</span><br><span class="line">此表的每一行都表示员工的ID、姓名和工资。它还包含他们所在部门的ID。</span><br></pre></td></tr></table></figure>
<p>表： Department</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> 列名         <span class="operator">|</span> 类型    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line"><span class="operator">|</span> id          <span class="operator">|</span> <span class="type">int</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name        <span class="operator">|</span> <span class="type">varchar</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+---------+</span></span><br><span class="line">id是此表的主键列。</span><br><span class="line">此表的每一行都表示一个部门的ID及其名称。</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">Employee 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span> salary <span class="operator">|</span> departmentId <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+--------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Joe   <span class="operator">|</span> <span class="number">70000</span>  <span class="operator">|</span> <span class="number">1</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Jim   <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span> <span class="number">1</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> Henry <span class="operator">|</span> <span class="number">80000</span>  <span class="operator">|</span> <span class="number">2</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> Sam   <span class="operator">|</span> <span class="number">60000</span>  <span class="operator">|</span> <span class="number">2</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Max   <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span> <span class="number">1</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------+--------------+</span></span><br><span class="line">Department 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> IT    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> Sales <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line">输出：</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> Department <span class="operator">|</span> Employee <span class="operator">|</span> Salary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br><span class="line"><span class="operator">|</span> IT         <span class="operator">|</span> Jim      <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sales      <span class="operator">|</span> Henry    <span class="operator">|</span> <span class="number">80000</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> IT         <span class="operator">|</span> Max      <span class="operator">|</span> <span class="number">90000</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+----------+--------+</span></span><br><span class="line">解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  department.Name <span class="keyword">AS</span> <span class="string">&#x27;Department&#x27;</span>,</span><br><span class="line">  employee.Name   <span class="keyword">AS</span> <span class="string">&#x27;Employee&#x27;</span>,</span><br><span class="line">  Salary</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line">  <span class="keyword">JOIN</span> department <span class="keyword">ON</span> employee.DepartmentId <span class="operator">=</span> department.Id</span><br><span class="line"><span class="keyword">WHERE</span> (employee.DepartmentId, Salary) <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    DepartmentId,</span><br><span class="line">    <span class="built_in">max</span>(Salary)</span><br><span class="line">  <span class="keyword">FROM</span> employee</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/department-highest-salary">https://leetcode.cn/problems/department-highest-salary</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>196. 删除重复的电子邮箱</title>
    <url>/posts/59823/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单</p>
<p>Write an SQL query to delete all the duplicate emails, keeping only one unique email with the smallest id. Note that you are supposed to write a DELETE statement and not a SELECT one.</p>
<p>After running your script, the answer shown is the Person table. The driver will first compile and run your piece of code and then show the Person table. The final order of the Person table does not matter.</p>
<p>编写一个SQL删除语句来<strong>删除</strong>所有重复的电子邮件，只保留一个id最小的唯一电子邮件。</p>
<p>以 任意顺序 返回结果表。 （注意： 仅需要写删除语句，将自动对剩余结果进行查询）</p>
<span id="more"></span>
<p><strong>SQL结构</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (Id <span class="type">int</span>, Email <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;bob@example.com&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (id, email) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;john@example.com&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">Person 表:</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> email            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> john<span class="variable">@example</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> bob<span class="variable">@example</span>.com  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> john<span class="variable">@example</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line">输出: </span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> email            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> john<span class="variable">@example</span>.com <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> bob<span class="variable">@example</span>.com  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------------------+</span></span><br><span class="line">解释: john<span class="variable">@example</span>.com重复两次。我们保留最小的Id <span class="operator">=</span> <span class="number">1</span>。</span><br></pre></td></tr></table></figure>
<p><strong>解法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> person p1, person p2</span><br><span class="line"><span class="keyword">WHERE</span> p1.Email <span class="operator">=</span> p2.Email <span class="keyword">AND</span> p1.Id <span class="operator">&gt;</span> p2.Id</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/delete-duplicate-emails">https://leetcode.cn/problems/delete-duplicate-emails</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>9. 回文数</title>
    <url>/posts/35052/</url>
    <content><![CDATA[<p><strong>难度系数：</strong> 简单<br />
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br />
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br />
例如，121 是回文，而 123 不是。</p>
<span id="more"></span>
<p><strong>示例 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">121</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：x = -<span class="number">121</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从左向右读, 为 -<span class="number">121</span> 。 从右向左读, 为 <span class="number">121</span>- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：x = <span class="number">10</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：从右向左读, 为 <span class="number">01</span> 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>约束条件</strong></p>
<ul>
<li>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</li>
</ul>
<p><strong>进阶：</strong> 你能不将整数转为字符串来解决这个问题吗？</p>
<p><strong>解法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">original</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">                result = result*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">                x = x/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(result == original)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原题链接：<a href="https://leetcode.cn/problems/palindrome-number">https://leetcode.cn/problems/palindrome-number</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Leetcode题解</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>1、代码评审开发者指南</title>
    <url>/posts/35152/</url>
    <content><![CDATA[<h2 id="introduction介绍"><a class="markdownIt-Anchor" href="#introduction介绍"></a> Introduction（介绍）</h2>
<p>A code review is a process where someone other than the author(s) of a piece of code examines that code.<br />
所谓的代码审查（code review）就是指让别人来审查自己的代码的过程。</p>
<p>At Google, we use code review to maintain the quality of our code and products.<br />
在Google内部，我们会通过代码审查来保证代码和产品的质量。</p>
<p>This documentation is the canonical description of Google’s code review processes and policies.<br />
本文档详述了Google是如何进行代码审查的以及所采用的策略。</p>
<span id="more"></span>
<p>This page is an overview of our code review process. There are two other large documents that are a part of this guide:</p>
<ul>
<li><strong><a href="../41083">How To Do A Code Review</a>:</strong> A detailed guide for code reviewers.</li>
<li><strong>The CL Author’s Guide:</strong> A detailed guide for developers whose CLs are going through review.</li>
</ul>
<p>本页内容大体介绍了下代码审查的过程是怎样的。代码审查指南包含了两大部分：</p>
<ul>
<li><strong><a href="../41083">如何进行代码审查</a>：</strong> 详述了代码评审人应该如何进行代码审查。</li>
<li><strong>变更列表作者指南：</strong> 详述了提交待审核变更列表的开发人员应该如何做。</li>
</ul>
<h2 id="what-do-code-reviewers-look-for代码审查应该关注哪些内容"><a class="markdownIt-Anchor" href="#what-do-code-reviewers-look-for代码审查应该关注哪些内容"></a> What Do Code Reviewers Look For?（代码审查应该关注哪些内容？）</h2>
<p>Code reviews should look at:</p>
<ul>
<li><strong>Design:</strong> Is the code well-designed and appropriate for your system?</li>
<li><strong>Functionality:</strong> Does the code behave as the author likely intended? Is the way the code behaves good for its users?</li>
<li><strong>Complexity:</strong> Could the code be made simpler? Would another developer be able to easily understand and use this code when they come across it in the future?</li>
<li><strong>Tests:</strong> Does the code have correct and well-designed automated tests?</li>
<li><strong>Naming:</strong> Did the developer choose clear names for variables, classes, methods, etc.?</li>
<li><strong>Comments:</strong> Are the comments clear and useful?</li>
<li><strong>Style:</strong> Does the code follow our <a href="http://google.github.io/styleguide/">style guides</a>?</li>
<li><strong>Documentation:</strong> Did the developer also update relevant documentation?</li>
</ul>
<p>代码审查内容应该关注以下几点：</p>
<ul>
<li><strong>设计：</strong> 代码是否设计良好且对于系统而言是否适合？</li>
<li><strong>功能：</strong> 代码实现的行为是否达到了作者想要的效果？代码实现的行为对于用户是否友好？</li>
<li><strong>复杂性：</strong> 代码能否写得更简单点吗？是否能让别的开发人员易于理解而且易于使用？</li>
<li><strong>测试：</strong> 代码是否包含了正确的，设计良好的自动化测试？</li>
<li><strong>命名：</strong> 开发人员是否为变量、类、方法等选取了清晰的名字？</li>
<li><strong>注释：</strong> 注释是否含义清晰并且有用？</li>
<li><strong>代码规范：</strong> 代码是否遵循了<a href="http://google.github.io/styleguide/">归约规范</a>？</li>
<li><strong>文档：</strong> 开发人员是否同步更新了相关文档？</li>
</ul>
<p>See <a href="../41083">How To Do A Code Review</a> for more information.<br />
具体内容详见<a href="../41083">《如何进行代码审查》</a>。</p>
<h3 id="picking-the-best-reviewers挑选最好的评审人"><a class="markdownIt-Anchor" href="#picking-the-best-reviewers挑选最好的评审人"></a> Picking the Best Reviewers（挑选最好的评审人）</h3>
<p>In general, you want to find the <em>best</em> reviewers you can who are capable of responding to your review within a reasonable period of time.<br />
通常情况下，你会倾向于寻找你所能找到的最好的评审人，以保证你的代码能尽快得到审查。</p>
<p>The best reviewer is the person who will be able to give you the most thorough and correct review for the piece of code you are writing. This usually means the owner(s) of the code, who may or may not be the people in the OWNERS file. Sometimes this means asking different people to review different parts of the CL.<br />
好的评审人能够给予你编写的代码较为彻底和正确的审查。这意味着，相关代码的所有者（owner）可能在所有者文件里也可能不在所有者文件里。有时可能需要让不同的人来去审查变更列表的不同部分。</p>
<p>If you find an ideal reviewer but they are not available, you should at least CC them on your change.<br />
如果你找到了理想的评审人但他们却因为某些原因无法为你审查时，你至少需要将你的变更内容抄送给他们。</p>
<h3 id="in-person-reviews-and-pair-programming面对面审查以及结对编程"><a class="markdownIt-Anchor" href="#in-person-reviews-and-pair-programming面对面审查以及结对编程"></a> In-Person Reviews (and Pair Programming)（面对面审查（以及结对编程））</h3>
<p>If you pair-programmed a piece of code with somebody who was qualified to do a good code review on it, then that code is considered reviewed.<br />
如果某部分代码你是与小伙伴结对编程写出来的，同时这个小伙伴被认为能进行合格的代码审查，那么这部分代码也可以被认为是进行过了代码审查。</p>
<p>You can also do in-person code reviews where the reviewer asks questions and the developer of the change speaks only when spoken to.<br />
你也可以采用面对面的代码审查方式，在这种方式下，评审人提出问题，被问的开发人员进行描述答复。</p>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title>3、代码审查标准</title>
    <url>/posts/51044/</url>
    <content><![CDATA[<p>The primary purpose of code review is to make sure that the overall code health of Google’s code base is improving over time. All of the tools and processes of code review are designed to this end.<br />
代码审查（code review）主要是为了确保Google代码库的整体代码质量能随着时间的推移而不断得到改善。代码审查的所有工具和步骤都是为了这个目的而设计的。</p>
<p>In order to accomplish this, a series of trade-offs have to be balanced.<br />
为了达到这个目的，我们必须做一系列的权衡折中。</p>
<span id="more"></span>
<p>First, developers must be able to make progress on their tasks. If you never submit an improvement to the codebase, then the codebase never improves. Also, if a reviewer makes it very difficult for any change to go in, then developers are disincentivized to make improvements in the future.<br />
首先，开发人员必须能够在他们自己的（开发）任务上取得进展。如果你从未向代码库提交过代码，那么代码库也不会产生变更。同样，如果评审人的评审标准过于苛刻，那么开发人员也会缺乏足够的动力去提交代码。</p>
<p>On the other hand, it is the duty of the reviewer to make sure that each CL is of such a quality that the overall code health of their codebase is not decreasing as time goes on. This can be tricky, because often, codebases degrade through small decreases in code health over time, especially when a team is under significant time constraints and they feel that they have to take shortcuts in order to accomplish their goals.<br />
另一方面，评审人应确保每次的代码变更都能达到这么一个状态：随着时间推移，代码库的整体质量不会下降。要做到这点可能会有点棘手，因为很多时候，代码库的质量会随着提交上来的代码的小幅质量下降而下降，尤其是当团队在处于时间很紧迫的情况下，为了完成任务，团队成员会觉得他们必须走一些捷径。</p>
<p>Also, a reviewer has ownership and responsibility over the code they are reviewing. They want to ensure that the codebase stays consistent, maintainable, and all of the other things mentioned in <a href="../16518">“What to look for in a code review.”</a><br />
同时，评审人对于他们在审核的代码拥有所有权和相应的责任。他们保证代码库的一致性，可维护性，以及<a href="../16518">《代码审查内容》</a>章节里提到的所以内容。</p>
<p>Thus, we get the following rule as the standard we expect in code reviews:<br />
因此，我们制定了以下规则作为代码审查的标准：</p>
<p><strong>In general, reviewers should favor approving a CL once it is in a state where it definitely improves the overall code health of the system being worked on, even if the CL isn’t perfect.</strong><br />
<strong>一般情况下，即使某次代码提交并不是很完美，但是它确实提高了系统的整体代码健康状态，那么评审人就应该通过它。</strong></p>
<p>That is the senior principle among all of the code review guidelines.<br />
这是代码审查指南的最高原则。</p>
<p>There are limitations to this, of course. For example, if a CL adds a feature that the reviewer doesn’t want in their system, then the reviewer can certainly deny approval even if the code is well-designed.<br />
当然，这条原则也有一些局限性。例如，如果某次代码提交添加了一个特性（feature），而该特性却不是评审人所想要加到系统里的，那么毋庸置疑，即使该次代码提交设计得再好，评审人也不会让其通过。</p>
<p>A key point here is that there is no such thing as “perfect” code—there is only better code. Reviewers should not require the author to polish every tiny piece of a CL before granting approval. Rather, the reviewer should balance out the need to make forward progress compared to the importance of the changes they are suggesting. Instead of seeking perfection, what a reviewer should seek is continuous improvement. A CL that, as a whole, improves the maintainability, readability, and understandability of the system shouldn’t be delayed for days or weeks because it isn’t “perfect.”<br />
这里有个比较关键的点，那就是，没有完美的代码，只有更好的代码。评审人不应该要求代码作者在代码评审通过前要对每次代码提交都进行“抛光打蜡”。相反，评审人应该在任务进度和代码建议的重要性之间取得平衡。评审人要追求的是持续改进，而不是一次性的完美。如果某次代码提交提高了系统的可维护性，可读性以及可理解性，那么它就不应该因为不够“完美”而被延迟几天或者几周才通过。</p>
<p>Reviewers should always feel free to leave comments expressing that something could be better, but if it’s not very important, prefix it with something like “Nit: “ to let the author know that it’s just a point of polish that they could choose to ignore.<br />
评审人在认为某些代码可以写得更好时，可以随时发表评论，但如果提出的点并不是非常重要，可以在评论前加个前缀“Nit: ”（Not Important的缩写），通过这个方式让代码作者知道：此处的评论只是一个更好的建议而已，如果选择了忽略，那也是可以的。</p>
<p>Note: Nothing in this document justifies checking in CLs that definitely worsen the overall code health of the system. The only time you would do that would be in an emergency.<br />
注意：本文档中虽然没有内容会证明检查代码提交会使整个系统的代码质量变差。但如果评审人在紧迫的情况下，这种现象也是会出现的。</p>
<h2 id="mentoring指导"><a class="markdownIt-Anchor" href="#mentoring指导"></a> Mentoring（指导）</h2>
<p>Code review can have an important function of teaching developers something new about a language, a framework, or general software design principles. It’s always fine to leave comments that help a developer learn something new. Sharing knowledge is part of improving the code health of a system over time. Just keep in mind that if your comment is purely educational, but not critical to meeting the standards described in this document, prefix it with &quot;Nit: &quot; or otherwise indicate that it’s not mandatory for the author to resolve it in this CL.<br />
代码审查有个很重要的作用，那就是可以传授开发人员有关语言、框架或者通用的软件设计原则方面的一些新东西。审查人员可以随时留下能帮助开发人员学到新东西的评论。分享知识也是提高系统代码质量的方式之一。不过要记住一点，就是，如果你的评论只是纯粹的指导性的，但对于满足本文档里所描述的标准这件事本身来说不重要，那么就应该在评论前面加上“Nit：”或者用别的方式标明，并非强制代码作者去解决该次代码变更的评论里提到的问题。</p>
<h2 id="principles原则"><a class="markdownIt-Anchor" href="#principles原则"></a> Principles（原则）</h2>
<ul>
<li>
<p>Technical facts and data overrule opinions and personal preferences.</p>
</li>
<li>
<p>技术事实和数据优先于观点和个人偏好。(译注：技术事实是需要一些实践、贸易或科学专业知识才能发现、验证、解释和理解的事实。技术事实和数据一般由公司沉淀而成。此处可以简单理解为做代码审查时产生的观点或者审查人的个人喜欢，应先遵从于公司既有的技术事实和数据。)</p>
</li>
<li>
<p>On matters of style, the <a href="http://google.github.io/styleguide/">style guide</a> is the absolute authority. Any purely style point (whitespace, etc.) that is not in the style guide is a matter of personal preference. The style should be consistent with what is there. If there is no previous style, accept the author’s.</p>
</li>
<li>
<p>在代码规范问题上，<a href="http://google.github.io/styleguide/">规范规约</a>是绝对权威。 任何不在样式指南中的规范风格（例如空格等）都是个人喜好问题。 代码规范应与现有的规范规约一致。 如果还没有规约，则接受作者的。</p>
</li>
<li>
<p><strong>Aspects of software design are almost never a pure style issue or just a personal preference.</strong> They are based on underlying principles and should be weighed on those principles, not simply by personal opinion. Sometimes there are a few valid options. If the author can demonstrate (either through data or based on solid engineering principles) that several approaches are equally valid, then the reviewer should accept the preference of the author. Otherwise the choice is dictated by standard principles of software design.</p>
</li>
<li>
<p><strong>软件设计的方方面面几乎从来都不是纯粹的规范问题或者只是个人偏好。</strong> 它们（指软件设计的各个方面）都基于一些基本原则，应根据这些原则进行权衡，而不仅仅只是个人意见。有时可能会有好几个可行的方案。如果作者能通过数据或者基于可靠的工程设计原则证明这些方案都行之有效，那么审查人员应该接受作者偏向的方案，否则就得给予软件设计的标准原则来做出决定。</p>
</li>
<li>
<p>If no other rule applies, then the reviewer may ask the author to be consistent with what is in the current codebase, as long as that doesn’t worsen the overall code health of the system.</p>
</li>
<li>
<p>如果没有其它适用的规则，那么审查人员需要要求作者于现有代码库的规则保持一致，因为这有才不会损坏系统的整体代码质量。</p>
</li>
</ul>
<h2 id="resolving-conflicts处理冲突译注指开发人员和代码审查人员的意见冲突"><a class="markdownIt-Anchor" href="#resolving-conflicts处理冲突译注指开发人员和代码审查人员的意见冲突"></a> Resolving Conflicts（处理冲突，译注：指开发人员和代码审查人员的意见冲突）</h2>
<p>In any conflict on a code review, the first step should always be for the developer and reviewer to try to come to consensus, based on the contents of this document and the other documents in <a href="../developer/index.md">The CL Author’s Guide</a> and this <a href="index.md">Reviewer Guide</a>.<br />
对于代码审查过程中产生的任何意见冲突，开发人员和审查人员第一步应该是尝试基于本文档的内容、变更列表作者指南以及审核人员指南达成一致意见。</p>
<p>When coming to consensus becomes especially difficult, it can help to have a face-to-face meeting or a video conference between the reviewer and the author, instead of just trying to resolve the conflict through code review comments. (If you do this, though, make sure to record the results of the discussion as a comment on the CL, for future readers.)<br />
当很难达成共识时，审查人员和代码作者可以进行面对面沟通或者是视频会议沟通，而不是只是仅通过审查评论来去解决冲突。（但如果确实是这么做的，那么要保证将讨论结果记录到代码变更的评论里，供后面的读者参考。）</p>
<p>If that doesn’t resolve the situation, the most common way to resolve it would be to escalate. Often the escalation path is to a broader team discussion, having a Technical Lead weigh in, asking for a decision from a maintainer of the code, or asking an Eng Manager to help out. <strong>Don’t let a CL sit around because the author and the reviewer can’t come to an agreement.</strong><br />
如果通过上述方式还没解决问题，则通常的做法是上升。通常情况下是上升到范围更广的小组讨论，技术leader参与进来，通过询问代码的维护人员来做出决定，或者是让工程经理提供帮助。<strong>不要让（有意见冲突的）代码变更放任不管，因为代码作者和审查人员无法达成统一意见。</strong></p>
<p>Next: <a href="../16518">What to look for in a code review</a><br />
下一章：<a href="../16518">代码审查内容</a></p>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title>Gerrit没有出现Verify按钮问题解决</title>
    <url>/posts/18923/</url>
    <content><![CDATA[<p>今天在本地修复了个小问题，然后提交到Gerrit。刚好老板看到了，提了点意见，给的分数为-2。对过意见后，做了点修改然后再一次提交到Gerrit，这时老板开会去了。找了另一个同事来review，但是发现即使给了+2分，也没有出现Verify按钮。鼓捣了老半天，才发现，原来，如果出现了-2，需要重新提交新的patch set，或者由给出-2分的成员批准才能Verify并入库。</p>
]]></content>
      <categories>
        <category>随笔备忘</category>
      </categories>
      <tags>
        <tag>Code Review</tag>
        <tag>Gerrit</tag>
      </tags>
  </entry>
  <entry>
    <title>6、处理代码评审过程产生的抵触问题</title>
    <url>/posts/45937/</url>
    <content><![CDATA[<p>Sometimes a developer will push back on a code review. Either they will disagree with your suggestion or they will complain that you are being too strict in general.<br />
有时开发人员可能会对某次代码审查结果产生抵触。他要么就是不同意你的建议，要么就是抱怨你太严格了。</p>
<span id="more"></span>
<h2 id="who-is-right"><a class="markdownIt-Anchor" href="#who-is-right"></a> Who is right?</h2>
<h2 id="谁是对的"><a class="markdownIt-Anchor" href="#谁是对的"></a> 谁是对的？</h2>
<p>When a developer disagrees with your suggestion, first take a moment to consider if they are correct. Often, they are closer to the code than you are, and so they might really have a better insight about certain aspects of it. Does their argument make sense? Does it make sense from a code health perspective? If so, let them know that they are right and let the issue drop.<br />
当开发人员不同意你的建议时，可以先花点时间考虑下他们是不是对的。通常，他们比你更接近代码，因此他们可能会对代码的某些方面有更好的了解。他们的异议是否有意义？从代码质量的角度来看这些争议是否有意义？如果是的话，那就让他们知道他们是对的，然后关闭问题。</p>
<p>However, developers are not always right. In this case the reviewer should further explain why they believe that their suggestion is correct. A good explanation demonstrates both an understanding of the developer’s reply, and additional information about why the change is being requested.<br />
然而，开发人员并不总是对的。在这种情况下，审查人员应该进一步解释为什么相信他们的建议是对的。一个好的解释不仅表明了对开发人员的回复的理解，也深入阐述了为什么要这么改。</p>
<p>In particular, when the reviewer believes their suggestion will improve code health, they should continue to advocate for the change, if they believe the resulting code quality improvement justifies the additional work requested. <strong>Improving code health tends to happen in small steps.</strong><br />
尤其是，当审查人员认为他们的建议会改善代码质量并且觉得由此带来的额外工作量是合理时，他们应该继续倡导修改。<strong>改善代码质量总是在小步中进行的。</strong></p>
<p>Sometimes it takes a few rounds of explaining a suggestion before it really sinks in. Just make sure to always stay <a href="comments.md#courtesy">polite</a> and let the developer know that you <em>hear</em> what they’re saying, you just don’t <em>agree</em>.<br />
有时需要来回对建议解释个几轮才能让开发人员真正理解。在这过程中，也要记得保证礼貌并且让开发人员知道你<em>知道</em>他们在说什么，只是不<em>同意</em>而已</p>
<h2 id="upsetting-developers"><a class="markdownIt-Anchor" href="#upsetting-developers"></a> Upsetting Developers</h2>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<p>Reviewers sometimes believe that the developer will be upset if the reviewer insists on an improvement. Sometimes developers do become upset, but it is usually brief and they become very thankful later that you helped them improve the quality of their code. Usually, if you are <a href="comments.md#courtesy">polite</a> in your comments, developers actually don’t become upset at all, and the worry is just in the reviewer’s mind. Upsets are usually more about <a href="comments.md#courtesy">the way comments are written</a> than about the reviewer’s insistence on code quality.<br />
审查人员有时会觉得如果审查人员坚持代码改进会让开发人员感到沮丧。开发人员有时也确实会感到沮丧，但这种感觉通常是短暂的，并且后续还会感激你帮助他们改善代码质量。通常情况下，如果你在评注里保持着礼貌，开发人员实际上是不会感到抗拒的，这个担心只是审查人员自身觉得的而已。比起审查人员坚持代码改善，反而是审查意见的编写方式更容易让开发人员感到不快。</p>
<h2 id="cleaning-it-up-later"><a class="markdownIt-Anchor" href="#cleaning-it-up-later"></a> Cleaning It Up Later</h2>
<h2 id="后续优化"><a class="markdownIt-Anchor" href="#后续优化"></a> 后续优化</h2>
<p>A common source of push back is that developers (understandably) want to get things done. They don’t want to go through another round of review just to get this CL in. So they say they will clean something up in a later CL, and thus you should LGTM <em>this</em> CL now. Some developers are very good about this, and will immediately write a follow-up CL that fixes the issue. However, experience shows that as more time passes after a developer writes the original CL, the less likely this clean up is to happen. In fact, usually unless the developer does the clean up <em>immediately</em> after the present CL, it never happens. This isn’t because developers are irresponsible, but because they have a lot of work to do and the cleanup gets lost or forgotten in the press of other work. Thus, it is usually best to insist that the developer clean up their CL <em>now</em>, before the code is in the codebase and “done.” Letting people “clean things up later” is a common way for codebases to degenerate.<br />
发生抵触的一个常见原因是开发人员想完成任务，这是可以理解的。他们不想为了让这个CL通过而进行新一轮的审查。因此他们会说他们会在后续的CL里进行优化，现在你应该先让我通过<em>这个</em>CL。一些开发人员很擅长做这个，还会立即写一个跟进事项。然而，经验表明，开发人员在写下原本的CL之后，随着时间推移，这些跟进事项会越来越难以得到实施。实际上多数情况是，除非开发人员<em>立马</em>处理这些问题，否则以后都不会处理。这不是因为开发人员没有责任心，而是因为他们有很多工作要做，从而这些跟进事项在其它工作的压力下被搁置或者遗忘。因此，最好坚持在代码入库前就让开发人员就处理好这些问题。让人们“稍后跟进”是代码质量下降的常见原因。</p>
<p>If a CL introduces new complexity, it must be cleaned up before submission unless it is an <a href="../emergencies.md">emergency</a>. If the CL exposes surrounding problems and they can’t be addressed right now, the developer should file a bug for the cleanup and assign it to themselves so that it doesn’t get lost. They can optionally also write a TODO comment in the code that references the filed bug.<br />
如果一个CL引入了新的复杂性，那么在提交到代码库前必须进行优化除非这是个紧急任务。如果这个CL暴露了一些别的问题而且无法立马解决，那么开发人员应该提交一个待跟进的bug并把它指派给自己，以此来让它不会被遗忘。开发人员也可以选择在代码里下一个TODO注释来提醒这个被记录下来的bug。</p>
<h2 id="general-complaints-about-strictness"><a class="markdownIt-Anchor" href="#general-complaints-about-strictness"></a> General Complaints About Strictness</h2>
<h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> </h2>
<p>If you previously had fairly lax code reviews and you switch to having strict reviews, some developers will complain very loudly. Improving the <a href="speed.md">speed</a> of your code reviews usually causes these complaints to fade away.<br />
如果你之前做代码审核比较宽松，然后（突然）转向严格的审查，一些开发人员会可能意见会比较大。提高你的代码审查<a href="speed.md">速度</a>通常能让这些抱怨消失。</p>
<p>Sometimes it can take months for these complaints to fade away, but eventually developers tend to see the value of strict code reviews as they see what great code they help generate. Sometimes the loudest protesters even become your strongest supporters once something happens that causes them to really see the value you’re adding by being strict.<br />
有时需要花几个月的时间来让这些抵触情绪消失，但最终开发人员会发现严格代码审查所带来的价值，因为他们看到了在审查人员的帮助下写出了出色的代码。一旦意见最大的那几个抗议者看到了你严格审查产生的价值，有时他们甚至会成为你的最坚定的支持者。</p>
<h2 id="resolving-conflicts"><a class="markdownIt-Anchor" href="#resolving-conflicts"></a> Resolving Conflicts</h2>
<h2 id="解决冲突"><a class="markdownIt-Anchor" href="#解决冲突"></a> 解决冲突</h2>
<p>If you are following all of the above but you still encounter a conflict between yourself and a developer that can’t be resolved, see <a href="../51044">The Standard of Code Review</a> for guidelines and principles that can help resolve the conflict.<br />
如果你遵从了上述几点但仍然和开发人员产生了难以解决的意见冲突，那么请参阅<a href="../51044">代码审查标准</a>章节，里面的指南和原则有助于解决冲突。</p>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title>2、如何进行代码审查</title>
    <url>/posts/41083/</url>
    <content><![CDATA[<h1 id="如何进行代码审查"><a class="markdownIt-Anchor" href="#如何进行代码审查"></a> 如何进行代码审查</h1>
<p>The pages in this section contain recommendations on the best way to do code reviews, based on long experience. All together they represent one complete document, broken up into many separate sections. You don’t have to read them all, but many people have found it very helpful to themselves and their team to read the entire set.</p>
<p>本文档包含了关于代码审查最佳实践的一些建议，这些建议都是基于长期实践总结出来的。我们将在不同的章节对它们进行阐述。你无需全部阅读它们，但很多人发现读完整个文档对他们自己或者团队都非常有帮助。</p>
<span id="more"></span>
<ul>
<li>
<p><a href="../51044">The Standard of Code Review</a></p>
</li>
<li>
<p><a href="../16518">What to Look For In a Code Review</a></p>
</li>
<li>
<p>Navigating a CL in Review</p>
</li>
<li>
<p>Speed of Code Reviews</p>
</li>
<li>
<p><a href="../12266">How to Write Code Review Comments</a></p>
</li>
<li>
<p><a href="../45937">Handling Pushback in Code Reviews</a></p>
</li>
<li>
<p><a href="../51044">代码审查的标准</a></p>
</li>
<li>
<p><a href="../16518">代码审查要做什么</a></p>
</li>
<li>
<p>在审查里定向变更记录</p>
</li>
<li>
<p>代码审查的速度</p>
</li>
<li>
<p><a href="../12266">如何编写代码审查评论</a></p>
</li>
<li>
<p><a href="../45937">处理代码评审过程产生的抵触问题</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title>5、如何写代码审查评论</title>
    <url>/posts/12266/</url>
    <content><![CDATA[<h1 id="how-to-write-code-review-comments"><a class="markdownIt-Anchor" href="#how-to-write-code-review-comments"></a> How to write code review comments</h1>
<h1 id="如何写代码审查评论"><a class="markdownIt-Anchor" href="#如何写代码审查评论"></a> 如何写代码审查评论</h1>
<h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ul>
<li>
<p>Be kind.</p>
</li>
<li>
<p>Explain your reasoning.</p>
</li>
<li>
<p>Balance giving explicit directions with just pointing out problems and letting the developer decide.</p>
</li>
<li>
<p>Encourage developers to simplify code or add code comments instead of just explaining the complexity to you.</p>
</li>
<li>
<p>语气要和善；</p>
</li>
<li>
<p>解释这么评论的原因；</p>
</li>
<li>
<p>在明确指示与指出问题之间做好平衡，并让开发人员自己决定；</p>
</li>
<li>
<p>鼓励开发人员简化代码或者增加注释，而不只是让他们向你就代码的复杂性进行说明。</p>
</li>
</ul>
<span id="more"></span>
<h2 id="courtesy"><a class="markdownIt-Anchor" href="#courtesy"></a> Courtesy</h2>
<h2 id="礼貌"><a class="markdownIt-Anchor" href="#礼貌"></a> 礼貌</h2>
<p>In general, it is important to be <a href="https://chromium.googlesource.com/chromium/src/+/master/docs/cr_respect.md">courteous and respectful</a> while also being very clear and helpful to the developer whose code you are reviewing. One way to do this is to be sure that you are always making comments about the <em>code</em> and never making comments about the <em>developer</em>. You don’t always have to follow this practice, but you should definitely use it when<br />
saying something that might otherwise be upsetting or contentious. For example:<br />
通常情况下，<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/cr_respect.md">礼貌和尊重</a>是很重要的，做到这两点对于其代码正在被审查的开发人员也是有帮助的。要做到这点的一个做法是，确保你只是对<em>代码</em>做评论，而不是<em>开发人员</em>本身。虽然你不用每次都这么做，但在说一些可能会令人不安或者有争议的话时，就一定要这么做。例如：</p>
<p>Bad: “Why did <strong>you</strong> use threads here when there’s obviously no benefit to be gained from concurrency?”<br />
反例：“为什么这里<strong>你</strong>要使用线程？很明显这里使用并发是没有好处的。”</p>
<p>Good: “The concurrency model here is adding complexity to the system without any actual performance benefit that I can see. Because there’s no performance benefit, it’s best for this code to be single-threaded instead of using multiple threads.”<br />
正例：“这里使用并发模型增加了系统复杂度，我从中看不到实际的性能优势。由于没有性能优势，这里最好使用单线程来替代多线程。”</p>
<h2 id="explain-why"><a class="markdownIt-Anchor" href="#explain-why"></a> Explain Why</h2>
<h2 id="解释为什么"><a class="markdownIt-Anchor" href="#解释为什么"></a> 解释为什么</h2>
<p>One thing you’ll notice about the “good” example from above is that it helps the developer understand <em>why</em> you are making your comment. You don’t always need to include this information in your review comments, but sometimes it’s appropriate to give a bit more explanation around your intent, the best practice you’re following, or how your suggestion improves code health.<br />
从上面的正例你会看到，那样子说明能帮助开发人员理解你的意见。虽然你不用每次都用这种形式来写评论意见，但有时应当适当地对你的意图、你所遵循的最佳实践，或者你的意见如何提高代码质量做多点解释。</p>
<h2 id="giving-guidance"><a class="markdownIt-Anchor" href="#giving-guidance"></a> Giving Guidance</h2>
<h2 id="给予指导"><a class="markdownIt-Anchor" href="#给予指导"></a> 给予指导</h2>
<p><strong>In general it is the developer’s responsibility to fix a CL, not the reviewer’s.</strong> You are not required to do detailed design of a solution or write code for the developer.<br />
<strong>一般情况下，修复CL是开发人员的责任，而不是审核人员的。</strong> 你无需为开发人员做具体的解决方案设计或者写代码。</p>
<p>This doesn’t mean the reviewer should be unhelpful, though. In general you should strike an appropriate balance between pointing out problems and providing direct guidance. Pointing out problems and letting the developer make a decision often helps the developer learn, and makes it easier to do code reviews. It also<br />
can result in a better solution, because the developer is closer to the code than the reviewer is.<br />
但这不意味着审查人员就不用提供帮助。通常，你应该在指出问题和提供指导之间取一个平衡。指出问题并且让开发人员做出决定通常能帮助开发人员学习，并且使得代码审查变得更容易。这么做同时还能产生更好的解决方案，毕竟开发人员才是更接近代码的。</p>
<p>However, sometimes direct instructions, suggestions, or even code are more helpful. The primary goal of code review is to get the best CL possible. A secondary goal is improving the skills of developers so that they require less and less review over time.<br />
然而，有时一些明确的指示，提示甚至是代码会更有用些。代码审查的主要目的是尽可能地获得最好的CL。第二个目的是为了提高开发人员的技能，以便随着时间的推移他们需要越来越少的代码审查。</p>
<p>Remember that people learn from reinforcement of what they are doing well and not just what they could do better. If you see things you like in the CL, comment on those too! Examples: developer cleaned up a messy algorithm, added exemplary test coverage, or you as the reviewer learned something from the CL. Just as with all comments, include <a href="#explain-why">why</a> you liked something, further encouraging the developer to continue good practices.<br />
请记住，当对人们做的好的地方（而不是能做得更好的地方）进行加强（译注：也就是鼓励）时，人们总是能从中得到学习。如果你在CL里看到了你喜欢的点，例如：开发人员清理了混乱的算法，添加了示例性的覆盖测试，或者你作为审查人员从CL里学到的东西，那么也请评注起来！同时，正如其它评注一样，这里的评注也要包含<a href="#explain-why">解释为什么</a>你喜欢这个地方，以此进一步鼓励开发人员继续这些好的实践。</p>
<h2 id="accepting-explanations"><a class="markdownIt-Anchor" href="#accepting-explanations"></a> Accepting Explanations</h2>
<h2 id="接受解释"><a class="markdownIt-Anchor" href="#接受解释"></a> 接受解释</h2>
<p>If you ask a developer to explain a piece of code that you don’t understand, that should usually result in them <strong>rewriting the code more clearly</strong>. Occasionally, adding a comment in the code is also an appropriate response, as long as it’s not just explaining overly complex code.<br />
如果你让开发人员解释一段你不理解的代码，这通常会使得他们<strong>重新把代码写得更清晰一点。</strong> 偶尔，在代码里添加一段注释也是个恰当的回应，前提是这段注释不仅仅只是为了解释过于复杂的代码。</p>
<p><strong>Explanations written only in the code review tool are not helpful to future code readers.</strong> They are acceptable only in a few circumstances, such as when you are reviewing an area you are not very familiar with and the developer explains something that normal readers of the code would have already known.<br />
<strong>只在code review工具里做解释对于以后的代码读者是没有好处的。</strong> 只有少数情况下才会这么做，例如当你在审查一个你不熟悉的功能模块，开发人员就可以解释一下一般读者已经理解的代码。</p>
<p>Next: <a href="pushback.md">Handling Pushback in Code Reviews</a></p>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
  <entry>
    <title>《人类简史》读后感</title>
    <url>/posts/34897/</url>
    <content><![CDATA[<p>作者：尤瓦尔·赫拉利（Yuval Noah Harari）<br />
推荐系数：5/5<br />
花了两周的地铁通勤时间二刷完了《人类简史》。书中不是完全按照时间轴来进行叙事性描述，加入了作者很多天马行空的思考与见解，具体事实或者推论是否真的会像作者说的那样历史学的不深也不好说。只是整本书下来，有两个观点很有意思：</p>
<ol>
<li>人类能大规模合作靠的是对想象出来的同一个故事的信任；</li>
<li>人类发展出来的信用体系使得近500年人类发展进程得以快速发展。感觉书中最后几章的讨论也给我们留下了个思考，我们到底快不快乐，快乐是主观的还是客观的。</li>
</ol>
<p>人类一思考，上帝就发笑。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《这才是心理学》读后感</title>
    <url>/posts/25743/</url>
    <content><![CDATA[<p>作者：基思·斯坦诺维奇（Keith E. Stanovich）<br />
推荐系数：4.5/5<br />
一直想读一本介绍心理学方面的书籍。这本书就挺适合的。心理学是一门年轻的基于科学实验的可证伪的学科。虽然头两章读起来有点像高中的政治书，但是越往后越能产生共鸣，甚至有好几章内容不自觉和平时的工作联系了起来，比如两个变量的关联性，多个角度证明同一个变量等。只是工作又参杂了人际的因素，也许正是因为如此，科学才显得更纯粹吧。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《动物庄园》读后感</title>
    <url>/posts/60962/</url>
    <content><![CDATA[<p>作者：乔治·奥威尔（George Orwell）<br />
推荐系数：5/5<br />
前几天同事提起这本书，说我像书里头的snowball，但整本看下来越发觉得我不是，我可能会偏理想主义，介于出世与入世之间，但是我同样会“大不了就不跟你玩”。中间有挺长的篇幅可以概括为“你看到的只是你看到的，你想到的只是我想让你想到的”。也许真的人类天性自私或者“乌合之众”容易被带偏，但其实我们要的归根到底其实只是吃得饱，穿的暖然后住得舒服就更好了。<br />
类似的书籍让我想起了《1984》<br />
嗯，看来我还是喜欢纯粹的知识，起码在代码里我还是自由的上帝。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《镜子》读后感</title>
    <url>/posts/39078/</url>
    <content><![CDATA[<p>作者：刘慈欣<br />
推荐系数：4.5/5<br />
不得不说，刘慈欣脑洞真大，反腐和宇宙大爆炸都能结合起来。我只是在想，可能也不一定水至清则无鱼，人至察则无徒，这个世界可塑性那么强到最后进化出了另一种生存模式另一种玩法也说不定。<br />
Anyway，真的是好看！而且我也是名软件工程师！</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>《行之有效》读后感</title>
    <url>/posts/24401/</url>
    <content><![CDATA[<p>作者：蔡为东<br />
推荐系数：3.5/5<br />
上个月大老板推荐了《行之有效》这本书，说是讲技术基层管理的。通篇看下来，其实就是告诉我们，基层管理者要多思考，多观察，以对团队有益作为出发点和原则，同时也不能落下自己的专业技能和素养。精华的点有以下几个：</p>
<ol>
<li>管理者负责。</li>
<li>以身作则。</li>
<li>公平和公开。</li>
<li>尊重每一个人。</li>
<li>提高员工参与度，让员工负责任。</li>
<li>随时激励。</li>
<li>提纲挈领，要事优先，管理优先。</li>
<li>培养人才，创造机会。</li>
<li>技术和管理一肩挑。</li>
<li>保持危机感，持续学习。</li>
<li>顺势而为。</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（五）--主题</title>
    <url>/posts/2339/</url>
    <content><![CDATA[<h1 id="topics主题"><a class="markdownIt-Anchor" href="#topics主题"></a> Topics（主题）</h1>
<p>In the previous tutorial we improved our messaging flexibility. Instead of using a fanout exchange only capable of dummy broadcasting, we used a direct one, and gained a possibility of selectively receiving the message based on the routing key.</p>
<p>在上一个教程里我们改善了我们的消息队列的灵活性。我们使用直接交换器来替代只会傻傻地广播消息的广播交换器，使得根据路由键来选择性接收消息成为了可能。</p>
<p>Although using the direct exchange improved our system, it still has limitations - it can’t do routing based on multiple criteria.</p>
<p>虽然使用直接交换器改善了我们的系统，但它仍然有一些限制——它无法根据多个标准来进行路由。</p>
<span id="more"></span>
<p>In our messaging system we might want to subscribe to not only queues based on the routing key, but also based on the source which produced the message. You might know this concept from the syslog unix tool, which routes logs based on both severity (info/warn/crit…) and facility (auth/cron/kern…). Our example is a little simpler than this.</p>
<p>在我们的消息队列系统中，我们可能不仅仅想订阅基于路由键的队列，可能还想订阅基于消息源的队列。你可以通过unix工具syslog来理解这个概念，这个工具同时基于严重级别（info/warn/crit…）和组件类型（auth/cron/kern…）来路由日志。我们的例子有点类似于这个。</p>
<p>That example would give us a lot of flexibility - we may want to listen to just critical errors coming from ‘cron’ but also all logs from ‘kern’.</p>
<p>这个例子将给予我们很大便利性—我们可能想监听级别为严重错误的日志，而且这些日志来自“cron”和“kern”。</p>
<p>To implement that flexibility in our logging system we need to learn about a more complex topic exchange.</p>
<p>为了在我们的日志系统中实现这个灵活性，我们需要了解更复杂的关于主题交换器的知识。</p>
<h2 id="topic-exchange主题交换器"><a class="markdownIt-Anchor" href="#topic-exchange主题交换器"></a> Topic exchange（主题交换器）</h2>
<p>Messages sent to a topic exchange can’t have an arbitrary routing_key - it must be a list of words, delimited by dots. The words can be anything, but usually they specify some features connected to the message. A few valid routing key examples: “stock.usd.nyse”, “nyse.vmw”, “quick.orange.rabbit”. There can be as many words in the routing key as you like, up to the limit of 255 bytes.</p>
<p>发送到主题交换器的消息不能有任意的路由键——它必须是一个由点号隔开的单词组。这些单词可以是任意词语，但通常情况下它们能说明消息的特征。举几个有效的路由键的例子：“stock.usd.nyse”，“nyse.vmw”，“quick.orange.rabbit”。路由键里的单词数你想要多少个都可以，但上限是255的字节。</p>
<p>The binding key must also be in the same form. The logic behind the topic exchange is similar to a direct one - a message sent with a particular routing key will be delivered to all the queues that are bound with a matching binding key. However there are two important special cases for binding keys:</p>
<p>绑定键也必须是相同的格式。主题交换器背后的逻辑类似于直接交换器——一条带着特定路由键的消息将会被发送所有绑定着匹配的绑定键的队列。不过，绑定键由两个重要的特殊情况：</p>
<p>*(star) can substitute for exactly one word.</p>
<p>星号可以替代一个单词。</p>
<p>#(hash) can substitute for zero or more words.</p>
<p>哈希号可以替代0个或多个单词。</p>
<p>It’s easiest to explain this in an example:</p>
<p>用一个例子可以很容易地解释：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-five.png" alt="image" /></p>
<p>In this example, we’re going to send messages which all describe animals. The messages will be sent with a routing key that consists of three words (two dots). The first word in the routing key will describe speed, second a colour and third a species: “&lt;speed&gt;.&lt;colour&gt;.&lt;species&gt;”.</p>
<p>在图例中，我们将发送所有描述动物的消息。每条消息将和包含着由三个单词组成（两个点号）的路由键一起被发送。路由键中的第一个单词将描述速度，第二个单词描述颜色，第三个单词描述种类，即格式为：“&lt;speed&gt;.&lt;colour&gt;.&lt;species&gt;”。</p>
<p>We created three bindings: Q1 is bound with binding key “*.orange.*” and Q2 with “*.*.rabbit” and “lazy.#”.</p>
<p>我们建立了三个绑定：队列Q1使用绑定键“*.orange.*”，队列Q2使用“*.*.rabbit”和“lazy.#”。</p>
<p>These bindings can be summarised as:</p>
<p>这些绑定可以总结描述为：</p>
<p>Q1 is interested in all the orange animals.</p>
<p>队列Q1对所有橙色的动物感兴趣。</p>
<p>Q2 wants to hear everything about rabbits, and everything about lazy animals.</p>
<p>队列Q2想监听所有的兔子，以及所有带有懒惰属性的动物。</p>
<p>A message with a routing key set to “quick.orange.rabbit” will be delivered to both queues. Message “lazy.orange.elephant” also will go to both of them. On the other hand “quick.orange.fox” will only go to the first queue, and “lazy.brown.fox” only to the second. “lazy.pink.rabbit” will be delivered to the second queue only once, even though it matches two bindings. “quick.brown.fox” doesn’t match any binding so it will be discarded.</p>
<p>带有路由键为“quick.orange.rabbit”的消息将同时被发送给队列Q1和Q2。带有路由键为“lazy.orange.elephant”的消息也同样将被发送给这两条队列。另一方面，路由键为“quick.orange.fox”的消息将仅被发送给队列Q1，而路由键为“lazy.brown.fox”的消息将仅被发送给队列Q2。路由键为“lazy.pink.rabbit”的消息将只被发送给队列Q2一次，即使它匹配队列Q2的两个绑定。路由键“quick.brown.fox”的消息由于不匹配任何绑定，所以它将被丢弃。</p>
<p>What happens if we break our contract and send a message with one or four words, like “orange” or “quick.orange.male.rabbit”? Well, these messages won’t match any bindings and will be lost.</p>
<p>如果我们打破了约定并发送了路由键为一个或四个单词的消息，如“orange”或者“quick.orange.male.rabbit”，会发生什么现象？没事，由于这些消息不能匹配任何绑定，所以它们也将被丢弃。</p>
<p>On the other hand “lazy.orange.male.rabbit”, even though it has four words, will match the last binding and will be delivered to the second queue.</p>
<p>另一方面，虽然“lazy.orange.male.rabbit”包含了四个词，但它匹配了最后一条绑定规则，所以它将被发送给队列Q2。</p>
<blockquote>
<h4 id="topic-exchange主题交换器-2"><a class="markdownIt-Anchor" href="#topic-exchange主题交换器-2"></a> Topic exchange（主题交换器）</h4>
<p>Topic exchange is powerful and can behave like other exchanges.</p>
<p>主题交换器很强大，而且还能表现出与其它类型的交换器相同的行为。</p>
<p>When a queue is bound with “#” (hash) binding key - it will receive all the messages, regardless of the routing key - like in fanout exchange.</p>
<p>当一个队列与“#”（哈希号）绑定键绑定时，它将接收所有的消息，而不管消息的路由键是什么，此时的队列看起来就像与广播交换器绑定了一样。</p>
<p>When special characters “*” (star) and “#” (hash) aren’t used in bindings, the topic exchange will behave just like a direct one.</p>
<p>当特殊符号“*”（星号）和“#”（哈希号）没有出现在绑定键时，主题交换器就表现得跟直接交换器一样。</p>
</blockquote>
<h2 id="putting-it-all-together代码整合"><a class="markdownIt-Anchor" href="#putting-it-all-together代码整合"></a> Putting it all together（代码整合）</h2>
<p>We’re going to use a topic exchange in our messaging system. We’ll start off with a working assumption that the routing keys will take advantage of both wildcards and a hash tag.</p>
<p>我们将在我们的消息队列系统中使用主题交换器。开始之前，我们先假设路由键将会用到通配符和哈希标签。</p>
<p>The code is almost the same as in the previous tutorial.</p>
<p>代码几乎与上一个教程的代码一样。</p>
<p>First let’s configure some profiles and beans in the Tut5Config.java of the tut5 package:</p>
<p>首先，我们在tut5包目录下新建Tut5Config.java，并在这个配置类里配置好一些配置组和bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut5&quot;,&quot;topics&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut5Config</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> TopicExchange <span class="title function_">topic</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;tut.topic&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;receiver&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReceiverConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut5Receiver <span class="title function_">receiver</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut5Receiver</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding1a</span><span class="params">(TopicExchange topic, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(topic).with(<span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding1b</span><span class="params">(TopicExchange topic, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(topic).with(<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding2a</span><span class="params">(TopicExchange topic, Queue autoDeleteQueue2)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue2).to(topic).with(<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;sender&quot;)</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Tut5Sender <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut5Sender</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We setup our profiles for executing the topics as the choice of “tut5” or “topics”. We then created the bean for our TopicExchange. The “receiver” profile is the ReceiverConfig defining our receiver, two AnonymousQueues as in the previous tutorial and the bindings for the topics utilizing the topic syntax. We also create the “sender” profile as the creation of the Tut5Sender class.</p>
<p>我们将配置组的名字设置为“tut5”或“topics”，要运行主题时任选一个即可。然后我们创建了类型为TopicExchange的bean。接收者配置组为ReceiveConfig类，在其里面定义了我们的接收者，两个AnonymousQueue类型的队列（就像上一个教程那样），同时还通过主体语法为主体定义了一系列绑定。我们还创建了发送者配置组，用于创建Tut5Sender类的bean。</p>
<p>The Tut5Receiver again uses the @RabbitListener to receive messages from the respective topics.</p>
<p>Tut5Receiver类同样使用了@RabbitListener来接收相应主题的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut5Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue1.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive1</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue2.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive2</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String in, <span class="type">int</span> receiver)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">		watch.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Received &#x27;&quot;</span> + in + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		doWork(in);</span><br><span class="line">		watch.stop();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Done in &quot;</span> + watch.getTotalTimeSeconds() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code for Tut5Sender.java:</p>
<p>以下为Tut5Sender.java的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut5Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TopicExchange topic;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] keys = &#123;<span class="string">&quot;quick.orange.rabbit&quot;</span>,</span><br><span class="line">	<span class="string">&quot;lazy.orange.elephant&quot;</span>, <span class="string">&quot;quick.orange.fox&quot;</span>,</span><br><span class="line">	<span class="string">&quot;lazy.brown.fox&quot;</span>, <span class="string">&quot;lazy.pink.rabbit&quot;</span>, <span class="string">&quot;quick.brown.fox&quot;</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello to &quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (++<span class="built_in">this</span>.index == keys.length) &#123;</span><br><span class="line">			<span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys[<span class="built_in">this</span>.index];</span><br><span class="line">		builder.append(key).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		builder.append(Integer.toString(++<span class="built_in">this</span>.count));</span><br><span class="line">		<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">		template.convertAndSend(topic.getName(), key, message);</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compile and run the examples as described in Tutorial 1 . Or if you have been following along through the tutorials you only need to do the following:</p>
<p>像教程1描述的那样去编译并运行实例代码。或者如果你是一直跟着教程学习的，那么你只需接着跟着往下做：</p>
<p>To build the project:</p>
<p>先构建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>To execute the sender and receiver with the correct profiles execute the jar with the correct parameters:</p>
<p>接着，分别使用正确的配置组来运行发送者和接收者，运行jar包时要使用正确的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=topics,receiver</span><br><span class="line">--tutorial.client.duration=60000</span><br><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=topics,sender</span><br><span class="line">--tutorial.client.duration=60000</span><br></pre></td></tr></table></figure>
<p>The output from the sender will look something like:</p>
<p>发送者进程的输出看起来是类似于下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ready ... running for 60000ms</span><br><span class="line">[x] Sent &#x27;Hello to lazy.orange.elephant 1&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to quick.orange.fox 2&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to lazy.brown.fox 3&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to lazy.pink.rabbit 4&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to quick.brown.fox 5&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to quick.orange.rabbit 6&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to lazy.orange.elephant 7&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to quick.orange.fox 8&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to lazy.brown.fox 9&#x27;</span><br><span class="line">[x] Sent &#x27;Hello to lazy.pink.rabbit 10&#x27;</span><br></pre></td></tr></table></figure>
<p>And the receiver will respond with the following output:</p>
<p>然后接收者进程的响应输出如下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instance 1 [x] Received &#x27;Hello to lazy.orange.elephant 1&#x27;</span><br><span class="line">instance 2 [x] Received &#x27;Hello to lazy.orange.elephant 1&#x27;</span><br><span class="line">instance 2 [x] Done in 2.005s</span><br><span class="line">instance 1 [x] Done in 2.005s</span><br><span class="line">instance 1 [x] Received &#x27;Hello to quick.orange.fox 2&#x27;</span><br><span class="line">instance 2 [x] Received &#x27;Hello to lazy.brown.fox 3&#x27;</span><br><span class="line">instance 1 [x] Done in 2.003s</span><br><span class="line">instance 2 [x] Done in 2.003s</span><br><span class="line">instance 1 [x] Received &#x27;Hello to lazy.pink.rabbit 4&#x27;</span><br><span class="line">instance 2 [x] Received &#x27;Hello to lazy.pink.rabbit 4&#x27;</span><br><span class="line">instance 1 [x] Done in 2.006s</span><br><span class="line">instance 2 [x] Done in 2.006s</span><br></pre></td></tr></table></figure>
<p>Have fun playing with these programs. Note that the code doesn’t make any assumption about the routing or binding keys, you may want to play with more than two routing key parameters.</p>
<p>可以多玩一玩这几个程序。注意，代码没有对路由或绑定键作任何假设，你可能需要使用两个以上的路由键参数。</p>
<p>(Full source code for <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Receiver.java">Tut5Receiver.java source</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Sender.java">Tut5Sender.java source</a>. The configuration is in <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Config.java">Tut5Config.java source</a>. )</p>
<p>（完整的代码请参阅<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Receiver.java">Tut5Receiver.java</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Sender.java">Tut5Sender.java</a> 。配置在<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut5/Tut5Config.java">Tut5Config.java</a>里）</p>
<p>Next, find out how to do a round trip message as a remote procedure call in tutorial 6.</p>
<p>接下来，我们将进入教程6，看看如何进行消息交互，即远程过程调用。</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（四）--路由</title>
    <url>/posts/48556/</url>
    <content><![CDATA[<h1 id="routing路由"><a class="markdownIt-Anchor" href="#routing路由"></a> Routing（路由）</h1>
<p>In the previous tutorial we built a simple fanout exchange. We were able to broadcast messages to many receivers.</p>
<p>在上一个教程里，我们构建了一个简单的广播交换器。通过它我们能将消息广播到多个接收者。</p>
<p>In this tutorial we’re going to add a feature to it - we’re going to make it possible to subscribe only to a subset of the messages. For example, we will be able to direct only messages to the certain colors of interest (“orange”, “black”, “green”), while still being able to print all of the messages on the console.</p>
<p>在本教程里，我们将往里添加一个功能——我们准备让接收者可以只订阅部分消息。例如，我们将只要某些我们感兴趣的颜色（“橙色”，“黑色”，“绿色”）的消息，但仍能在控制台里打印出所有的信息。</p>
<span id="more"></span>
<h2 id="bindings绑定"><a class="markdownIt-Anchor" href="#bindings绑定"></a> Bindings（绑定）</h2>
<p>In previous examples we were already creating bindings. You may recall code like this in our Tut3Config file:</p>
<p>在之前的例子当中，我们创建了绑定器。通过下面的代码片段回顾下我们的Tut3Config配置文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding1</span><span class="params">(FanoutExchange fanout, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(fanout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A binding is a relationship between an exchange and a queue. This can be simply read as: the queue is interested in messages from this exchange.</p>
<p>交换器和队列是通过绑定器连结在一起的。这种关系可以读作：这个队列对这个交换器里的消息感兴趣。</p>
<p>Bindings can take an extra routingKey parameter. Spring-amqp uses a fluent API to make this relationship very clear. We pass in the exchange and queue into the BindingBuilder and simply bind the queue “to” the exchange “with a routing key” as follows:</p>
<p>可以再传一个路由键（routingKey）参数给绑定。在这点上，Spring-amqp使用了流式API，使得队列，交换器和路由键之间的关系变得很清晰。我们将某个交换器和某个队列传给BindingBuilder，将传入的队列用某个路由键绑定到传入的交换器上，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding1a</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(direct).with(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The meaning of a binding key depends on the exchange type. The fanout exchanges, which we used previously, simply ignored its value.</p>
<p>绑定键的含义取决与交换器的类型。我们之前使用的广播交换器就忽略了这个值。</p>
<h2 id="direct-exchange直接交换器"><a class="markdownIt-Anchor" href="#direct-exchange直接交换器"></a> Direct exchange（直接交换器）</h2>
<p>Our messaging system from the previous tutorial broadcasts all messages to all consumers. We want to extend that to allow filtering messages based on their color type. For example, we may want a program which writes log messages to the disk to only receive critical errors, and not waste disk space on warning or info log messages.</p>
<p>在上一个教程里，我们的消息队列系统将所有消息广播给所有的消费者。现在我们需要让消息队列系统可以基于消息的颜色类型进行消息过滤。例如，对于一个将日志消息写入磁盘的程序，我们可能只想让它接收严重错误类型的日志消息，而不是警告或者信息级别的日志消息，从而不致于浪费磁盘空间。</p>
<p>We were using a fanout exchange, which doesn’t give us much flexibility - it’s only capable of mindless broadcasting.</p>
<p>在上一个教程里，我们用到的广播交换器不能给我们这个灵活性，因为它只会做机械广播。</p>
<p>We will use a direct exchange instead. The routing algorithm behind a direct exchange is simple - a message goes to the queues whose binding key exactly matches the routing key of the message.</p>
<p>我们将使用直连交换器来替换它。直连交换器背后的路由算法很简单——当消息被推入到某个队列时，这个队列绑定的键要与消息的路由键完全匹配。</p>
<p>To illustrate that, consider the following setup:</p>
<p>为了说明这一点，考虑下面的情况：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="image" /></p>
<p>In this setup, we can see the direct exchange X with two queues bound to it. The first queue is bound with binding key orange, and the second has two bindings, one with binding key black and the other one with green.</p>
<p>从图中我们可以看到，有两个队列绑定了直连交换器X。第一个队列绑定时用了orange键，第二个队列用了两个，一个是black键，另一个是green键。</p>
<p>In such a setup a message published to the exchange with a routing key orange will be routed to queue Q1. Messages with a routing key of black or green will go to Q2. All other messages will be discarded.</p>
<p>在这种情况下，带有orange路由键的消息被发布到交换器时，会被路由到队列Q1。带有black键或green键的消息将被推入到队列Q2。所有其它的消息将被丢弃。</p>
<h2 id="multiple-bindings多绑定"><a class="markdownIt-Anchor" href="#multiple-bindings多绑定"></a> Multiple bindings（多绑定）</h2>
<p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange-multiple.png" alt="image" /></p>
<p>It is perfectly legal to bind multiple queues with the same binding key. In our example we could add a binding between X and Q1 with binding key black. In that case, the direct exchange will behave like fanout and will broadcast the message to all the matching queues. A message with routing key black will be delivered to both Q1 and Q2.</p>
<p>多个队列用同个键绑定到同个交换器是完全合法的。在我们的例子当中，我们可以用键black在交换器X和队列Q1之间添加绑定。在这种情况下，直接交换器的行为将和广播交换器一样，将消息广播给所有匹配的队列。带有路由键black的消息将被发送给队列Q1和队列Q2。</p>
<h2 id="publishing-messages发布消息"><a class="markdownIt-Anchor" href="#publishing-messages发布消息"></a> Publishing messages（发布消息）</h2>
<p>We’ll use this model for our routing system. Instead of fanout we’ll send messages to a direct exchange. We will supply the color as a routing key. That way the receiving program will be able to select the color it wants to receive (or subscribe to). Let’s focus on sending messages first.</p>
<p>我们将在我们的路由系统中使用这种模型。我们将发送消息给直连交换器，而不是广播交换器。我们将使用颜色作为路由键。这么做的话接收者程序就可以选择它想接收（或者说订阅）的颜色。让我们先看看如何发送消息。</p>
<p>As always, we do some spring boot configuration in Tut4Config:</p>
<p>照例，我们在Tut4Config配置文件里做些spring boot配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;tut.fanout&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And we’re ready to send a message. Colors, as in the diagram, can be one of ‘orange’, ‘black’, or ‘green’.</p>
<p>现在我们准备发送一条消息。如图所示，颜色可以是&quot;orange&quot;，“black”，或者“green”</p>
<h2 id="subscribing订阅"><a class="markdownIt-Anchor" href="#subscribing订阅"></a> Subscribing（订阅）</h2>
<p>Receiving messages will work just like in the previous tutorial, with one exception - we’re going to create a new binding for each color we’re interested in. This also goes into the Tut4Config.</p>
<p>接收消息将会像上一个教程那样，除了有一点不同——我们将为每一个我们感兴趣的颜色创建一个新的绑定器。这一点也将在Tut4Config里体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">direct</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;tut.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding1a</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(direct).with(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="putting-it-all-together整合代码"><a class="markdownIt-Anchor" href="#putting-it-all-together整合代码"></a> Putting it all together（整合代码）</h2>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-four.png" alt="image" /></p>
<p>As in the previous tutorials, create a new package for this tutorial called “tut4” and create the Tut4Config class. The code for Tut4Config.java class:</p>
<p>像之前的教程那样，为本教程创建一个新的包目录“tut4”，并创建Tut4Config类。以下为TutConfig.java的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut4&quot;,&quot;routing&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut4Config</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">direct</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;tut.direct&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;receiver&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReceiverConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding1a</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(direct).with(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding1b</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(direct).with(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding2a</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue2).to(direct).with(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding2b</span><span class="params">(DirectExchange direct, Queue autoDeleteQueue2)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue2).to(direct).with(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut4Receiver <span class="title function_">receiver</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut4Receiver</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;sender&quot;)</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Tut4Sender <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut4Sender</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code for our sender class is:</p>
<p>我们的发送者类是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut4Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DirectExchange direct;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] keys = &#123;<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;green&quot;</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello to &quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (++<span class="built_in">this</span>.index == <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys[<span class="built_in">this</span>.index];</span><br><span class="line">		builder.append(key).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">		builder.append(Integer.toString(++<span class="built_in">this</span>.count));</span><br><span class="line">		<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">		template.convertAndSend(direct.getName(), key, message);</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code for Tut4Receiver.java is:</p>
<p>然后下面为Tut4Receiver.java的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut4Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue1.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive1</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue2.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive2</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String in, <span class="type">int</span> receiver)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">		watch.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Received &#x27;&quot;</span> + in + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		doWork(in);</span><br><span class="line">		watch.stop();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Done in &quot;</span> + watch.getTotalTimeSeconds() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compile as usual (see tutorial one for maven compilation and executing the options from the jar).</p>
<p>像之前那样去编译（对于如何用maven进行编译以及如何通过参数来运行jar包，请见教程1）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>In one terminal window you can run:</p>
<p>打开一个终端窗口，运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=routing,receiver</span><br><span class="line">--tutorial.client.duration=60000</span><br></pre></td></tr></table></figure>
<p>and in the other temrinal window run the sender：</p>
<p>打开另一个终端窗口，输入以下命令来运行发送者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=routing,sender</span><br><span class="line">--tutorial.client.duration=60000</span><br></pre></td></tr></table></figure>
<p>Full source code for <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Receiver.java">Tut4Receiver.java source</a> and <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Sender.java">Tut4Sender.java source</a>. The configuration is in<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Config.java">Tut4Config.java source</a>.</p>
<p>完整的源代码可以参考<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Receiver.java">Tut4Receiver.java源码</a>和<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Sender.java">Tut4Sender.java源码</a>。配置类请参考<a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut4/Tut4Config.java">Tut4Config.java源码</a></p>
<p>Move on to tutorial 5 to find out how to listen for messages based on a pattern.</p>
<p>下面开始教程5，看看如何基于主题来监听消息。</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（一）--Hello World</title>
    <url>/posts/53264/</url>
    <content><![CDATA[<h1 id="1-hello-world"><a class="markdownIt-Anchor" href="#1-hello-world"></a> 1 “Hello World!”</h1>
<h2 id="introduction简介"><a class="markdownIt-Anchor" href="#introduction简介"></a> Introduction（简介）</h2>
<p>RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that Mr. Postman will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office and a postman.</p>
<p>RabbitMQ是一个消息代理：它接受并转发消息。你可以将它看成是一个邮局：当你将想发送的邮件丢进邮箱时，你就可以确定邮差最终会把这封邮件送到收件人手上。通过这个类比来看，RabbitMQ既是邮箱，又是邮局，而且还是邮差。</p>
<span id="more"></span>
<p>The major difference between RabbitMQ and the post office is that it doesn’t deal with paper, instead it accepts, stores and forwards binary blobs of data ‒ <em>messages</em>.</p>
<p>RabbitMQ和邮局之间的主要不同点是，RabbitMQ不跟纸打交道，它只接收，存储并转发二进制的数据包—消息。</p>
<p>RabbitMQ, and messaging in general, uses some jargon.</p>
<p>RabbitMQ，一般称它为消息队列，它使用了一些术语。</p>
<p><em>Producing</em> means nothing more than sending. A program that sends messages is a producer:</p>
<p>消息生产其实就是消息发送。发送消息的程序就是生产者：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/producer.png" alt="image" /></p>
<p>A <em>queue</em> is the name for a post box which lives inside RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a <em>queue</em>. A queue is only bound by the host’s memory &amp; disk limits, it’s essentially a large message buffer. Many producers can send messages that go to one queue, and many consumers can try to receive data from one <em>queue</em>. This is how we represent a queue:</p>
<p>队列就是相当于RabbitMQ内部的邮箱。虽然消息在传递时是流经RabbitMQ和你的应用，但它们只能被存储在某个队列里。队列大小只受限于主机内存和硬盘容量，它本质上就是个大的消息缓存。多个生产者可以往一个队列里发送消息，多个消费者可以从一个队列里获取数据。以下是我们表示一个队列的方式：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/queue.png" alt="image" /></p>
<p><em>Consuming</em> has a similar meaning to receiving. A <em>consumer</em> is a program that mostly waits to receive messages:</p>
<p>消息消费其实就是消息接收。等待接收消息的程序就是一个消费者：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/consumer.png" alt="image" /></p>
<p>Note that the producer, consumer, and broker do not have to reside on the same host; indeed in most applications they don’t.</p>
<p>注意，生产者，消费者和代理不一定都在同一个主机里；实际上，在大多数应用中，这三者都不是在同一个主机里。</p>
<h2 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> “Hello World”</h2>
<p>In this part of the tutorial we’ll write two programs using the spring-amqp library; a producer that sends a single message, and a consumer that receives messages and prints them out. We’ll gloss over some of the detail in the Spring-amqp API, concentrating on this very simple thing just to get started. It’s a “Hello World” of messaging.</p>
<p>在本教程里，我们将写两个基于spring-amqp类库的程序，其中一个是发送单条消息的生产者，另一个是消费者，它接收消息并将它们打印出来。我们将省略Spring-amqp API的一些细节，专注于即将开始的东西。它是消息队列版本的“Hello World”程序。</p>
<p>In the diagram below, “P” is our producer and “C” is our consumer. The box in the middle is a queue - a message buffer that RabbitMQ keeps on behalf of the consumer.</p>
<p>在下面的图中，“P”是我们的生产者，“C”是我们的消费者。图中间的箱子是一个队列，也就是RabbitMQ给消费者用的的消息缓存：</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-one.png" alt="image" /></p>
<blockquote>
<h4 id="the-spring-amqp-frameworkspring-amqp框架"><a class="markdownIt-Anchor" href="#the-spring-amqp-frameworkspring-amqp框架"></a> The Spring AMQP Framework（Spring AMQP框架）</h4>
<p>RabbitMQ speaks multiple protocols. This tutorial uses AMQP 0-9-1, which is an open, general-purpose protocol for messaging. There are a number of clients for RabbitMQ in many different languages.</p>
<p>RabbitMQ支持多种协议。本教程使用AMQP 0-9-1协议，它是一个开放，通用的消息队列协议。很多编程语言都提供了RabbitMQ客户端。</p>
</blockquote>
<p>Spring AMQP leverages Spring Boot for configuration and dependency management. Spring supports maven or gradle but for this tutorial we’ll select maven with Spring Boot 1.5.2. Open the <a href="http://start.spring.io/">Spring Initializr</a> and provide: the group id (e.g. org.springframework.amqp.tutorials) the artifact id (e.g. rabbitmq-amqp-tutorials). Search for the amqp dependency and select the AMQP dependency.</p>
<p>Spring AMQP利用Spring Boot来进行配置和依赖管理。Spring同时支持maven或者gradle，但在本教程里我们选择用maven，同时采用Spring Boot 1.5.2版本。我们打开<a href="http://start.spring.io/">Spring Initializr</a>并提供group id（如org.springframework.amqp.tutorials）和artifact id（如rabbitmq-amqp-tutorials）。查找amqp依赖并选择AMQP依赖。（译者注：应该是搜索rabbitmq）</p>
<p>Generate the project and unzip the generated project into the location of your choice. This can now be imported into your favorite IDE. Alternatively you can work on it from your favorite editor.</p>
<p>点击Generate Project生成项目，下载并将其解压到你想存放的目录。现在你可以在你喜欢的IDE里面导入这个项目。你也可以在你喜欢的编辑器上进行下一步编辑。</p>
<h3 id="configuring-the-project配置项目"><a class="markdownIt-Anchor" href="#configuring-the-project配置项目"></a> Configuring the project（配置项目）</h3>
<p>Spring Boot offers numerous features but we will only highlight a few here. First, Spring Boot applications have the option of providing their properties through either an application.properties or application.yml file (there are many more options as well but this will get us going). You’ll find an application.properties file in the generated project with nothing in it. Rename application.properties to application.yml file with the following properties:</p>
<p>Spring Boot提供了很多特性，但在这里我们只显示几个需要用到的。首先，Spring Boot应用的配置可以写在application.properties文件或者application.yml文件里（还有许多其它的方式，但对于我们，用这两种文件就足够了）。你在生成的项目里将会找到一个空的application.properties文件。将这个文件重命名为application.yml，并写上这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles:</span><br><span class="line">        active: usage_message</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">    level:</span><br><span class="line">        org: ERROR</span><br><span class="line"></span><br><span class="line">tutorial:</span><br><span class="line">    client:</span><br><span class="line">        duration: 10000</span><br></pre></td></tr></table></figure>
<p>Create a new directory (package - tut1) where we can put the tutorial code. We’ll now create a JavaConfig file (Tut1Config.java) to describe our beans in the following manner:</p>
<p>创建一个新的目录（package - tut1）用来放我们的教程代码。现在我们将通过以下方式创建一个Java配置文件（Tut1Config.java）来描述我们的Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.tutorials.tut1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut1&quot;,&quot;hello-world&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut1Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;receiver&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Tut1Receiver <span class="title function_">receiver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut1Receiver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;sender&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Tut1Sender <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut1Sender</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we’ve defined the 1st tutorial profile as either tut1, the package name, or hello-world. We use the @Configuration to let Spring know that this is a Java Configuration and in it we create the definition for our Queue (“hello”) and define our Sender and Receiver beans.</p>
<p>注意，我们已经将教程的第一个配置组定义为tu1（即报名），或者hello-world。我们用@Configuration注解来让Spring知道这是个Java配置，并且在配置里我们定义了队列Queue(“hello”)，而且也定义了我们的发送者和接收者。</p>
<p>We will run all of our tutorials through the Boot Application now by simply passing in which profiles we are using. To enable this we will modify the generated RabbitAmqpTutorialsApplication.java with the following:</p>
<p>现在我们将传入需要用到配置组，通过Boot Application来运行我们的教程。为了做到这一点，我们将修改生成的RabbitAmqpTutorialsApplication.java文件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAmqpTutorialsApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;usage_message&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommandLineRunner <span class="title function_">usage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandLineRunner</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... arg0)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This app uses Spring Profiles to control its behavior.\n&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Sample usage: java -jar rabbit-tutorials.jar --spring.profiles.active=helloworld,sender&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Profile(&quot;!usage_message&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommandLineRunner <span class="title function_">tutorial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RabbitAmqpTutorialsRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        SpringApplication.run(RabbitAmqpTutorialsApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>and add the RabbitAmqpTutorialsRunner.java code as follows:</p>
<p>然后像下面那样添加RabbitAmqpTutorialsRunner.java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.tutorials;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitAmqpTutorialsRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;tutorial.client.duration:0&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext ctx;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... arg0)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ready ... running for &quot;</span> + duration + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        Thread.sleep(duration);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sending发送"><a class="markdownIt-Anchor" href="#sending发送"></a> Sending（发送）</h3>
<p><img src="https://www.rabbitmq.com/img/tutorials/sending.png" alt="image" /></p>
<p>Now there is very little code that needs to go into the sender and receiver classes. Let’s call them Tut1Receiver and Tut1Sender. The Sender leverages our config and the RabbitTemplate to send the message.</p>
<p>现在发送者类和接收者类需要写的代码很少。我们把接收者的类名叫做Tut1Receiver，把发送者的类名叫做Tut1Sender。发送者类利用我们的配置和RabbitTemplate类来发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sender</span></span><br><span class="line"><span class="keyword">package</span> org.springframework.amqp.tutorials.tut1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut1Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.template.convertAndSend(queue.getName(), message);</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You’ll notice that spring-amqp removes the boiler plate code leaving you with only the logic of the messaging to be concerned about. We autowire in the queue that was configured in our bean definition in the Tut1Config class and like many spring connection abstractions, we wrap the boilerplate rabbitmq client classes with a RabbitTemplate that can be autowired into the sender. All that is left is to create a message and invoke the template’s convertAndSend method passing in the queue name from the bean we defined and the message we just created.</p>
<p>你会发觉，spring-amqp移除了样板化代码，让你只专注于消息发送逻辑。我们自动注入了队列queue，它已经在前面的Tut1Config类里做了配置。就像大多数Spring连接抽象，我们用RabbitTemplate包装了样板化的rabbitmq客户端类，并将它自动注入到发送者类里。我们要做的就是创建一条信息，并调用template的convertAndSend方法，传入我们定义的队列bean的名字以及我们刚创建的信息。</p>
<blockquote>
<h4 id="sending-doesnt-work无法发送"><a class="markdownIt-Anchor" href="#sending-doesnt-work无法发送"></a> Sending doesn’t work!（无法发送！）</h4>
<p>If this is your first time using RabbitMQ and you don’t see the “Sent” message then you may be left scratching your head wondering what could be wrong. Maybe the broker was started without enough free disk space (by default it needs at least 200 MB free) and is therefore refusing to accept messages. Check the broker logfile to confirm and reduce the limit if necessary. The configuration file documentation will show you how to set disk_free_limit.</p>
<p>如果这是你第一次使用RabbitMQ并且你看不到打印出来的“Sent”消息，你可能会在那里苦恼着哪里出错了。也许消息代理在启动时不够磁盘空间（默认它需要200MB的空间），由此导致拒绝接收信息。如有必要，检查代理的日志文件来确认并减少所需最小磁盘空间的限制。配置文件文档里会告诉你如何设置disk_free_limit（最小所需磁盘空间）参数</p>
</blockquote>
<h3 id="receiving接收"><a class="markdownIt-Anchor" href="#receiving接收"></a> Receiving（接收）</h3>
<p>The receiver is equally simple. We annotate our Receiver class with @RabbitListener and pass in the name of the queue. We then annotate our receive method with @RabbitHandler passing in the payload that has been pushed to the queue.</p>
<p>接收者类很简单。我们用@RabbitListener来注解我们的接收者类，并往注解里传入队列的名字。然后我们用@RabbitHandler来注解我们的接收方法，接收的参数为推入队列里的负载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.tutorials.tut1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut1Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String in)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + in + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="putting-it-all-together代码整合"><a class="markdownIt-Anchor" href="#putting-it-all-together代码整合"></a> Putting it all together（代码整合）</h3>
<p>The app uses Spring Profiles to control what tutorial it’s running, and whether it’s a Sender or Receiver. Choose which tutorial to run by using the profile. For example:</p>
<p>程序通过使用Spring配置组来控制正在运行的是哪个教程代码，以及控制正在运行的是发送者还是接收者。我们选择使用不同的配置组来运行不同的教程代码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- &#123;tut1|hello-world&#125;,&#123;sender|receiver&#125;</span><br><span class="line">- &#123;tut2|work-queues&#125;,&#123;sender|receiver&#125;</span><br><span class="line">- &#123;tut3|pub-sub|publish-subscribe&#125;,&#123;sender|receiver&#125;</span><br><span class="line">- &#123;tut4|routing&#125;,&#123;sender|receiver&#125;</span><br><span class="line">- &#123;tut5|topics&#125;,&#123;sender|receiver&#125;</span><br><span class="line">- &#123;tut6|rpc&#125;,&#123;client|server&#125;</span><br></pre></td></tr></table></figure>
<p>We’ll come back to this list as we progress through the other five tutorials. After building with maven, run the app however you like to run boot apps (e.g. from the ide, or command line). We’ll show how to run from the command line.</p>
<p>涉及到其它五个教程时我们还会回来参照这个列表。用maven构建完后，你可以用你喜欢的方式来运行程序（例如，通过ide或通过命令行）。我们将展示如何通过命令行来运行。</p>
<p>For example（例如）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># publisher</span><br><span class="line">java -jar rabbitmq-tutorials.jar --spring.profiles.active=hello-world,sender</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># consumer</span><br><span class="line">java -jar rabbitmq-tutorials.jar --spring.profiles.active=hello-world,receiver</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="listing-queues列出队列"><a class="markdownIt-Anchor" href="#listing-queues列出队列"></a> Listing queues（列出队列）</h4>
<p>You may wish to see what queues RabbitMQ has and how many messages are in them. You can do it (as a privileged user) using the rabbitmqctl tool:</p>
<p>你可能希望看一下RabbitMQ有哪些队列，这些队列里有多少消息。你可以通过使用rabbitmqctl工具来查看（但你必须是个授权用户）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues</span><br></pre></td></tr></table></figure>
<p>On Windows, omit the sudo:</p>
<p>在Windows系统上，输入命令时要去掉sudo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl.bat list_queues</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Time to move on to part 2 and build a simple <em>work queue</em>.</p>
<p>接下来我们开始教程的第2部份，并构建一个简单的工作队列。</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（六）--RPC</title>
    <url>/posts/40514/</url>
    <content><![CDATA[<h1 id="remote-procedure-call-rpc远程过程调用"><a class="markdownIt-Anchor" href="#remote-procedure-call-rpc远程过程调用"></a> Remote procedure call (RPC，远程过程调用)</h1>
<p>In the second tutorial we learned how to use <em>Work Queues</em> to distribute time-consuming tasks among multiple workers.</p>
<p>在教程2里我们学习了如何使用工作队列在多个工作者之间分发耗时任务。</p>
<p>But what if we need to run a function on a remote computer and wait for the result? Well, that’s a different story. This pattern is commonly known as <em>Remote Procedure Call or RPC</em>.</p>
<p>但如果我们需要在一个远程电脑上运行一个函数并且等待运行结果的话要怎么办呢？这就变成另一个问题了。这种模式通常被称为远程过程调用（Remote Procedure Call），或者简称RPC。</p>
<p>In this tutorial we’re going to use RabbitMQ to build an RPC system: a client and a scalable RPC server. As we don’t have any time-consuming tasks that are worth distributing, we’re going to create a dummy RPC service that returns Fibonacci numbers.</p>
<p>在本节教程里，我们将用RabbitMQ来构建一个RPC系统，这个系统包括一个客户端和一个可伸缩的RPC服务端。由于我们没有什么耗时任务值得分发，所以我们准备创建一个假的RPC服务，这个服务返回斐波那契（Fibonacci）数值。</p>
<span id="more"></span>
<h3 id="client-interface客户端接口"><a class="markdownIt-Anchor" href="#client-interface客户端接口"></a> Client interface（客户端接口）</h3>
<p>To illustrate how an RPC service could be used we’re going to change the names of our profiles from “Sender” and &quot;Receiver” to “Client” and “Server”. When we call the server we will get back the fibonacci of the argument we call with.</p>
<p>为了说明RPC服务可以如何被使用，我们准备修改我们的配置组，将名称从“Sender”和“Receiver”换成“Client”和“Server”。当我们调用服务端时，我们将会获得我们传入的参数所对应的斐波那契数值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">response</span> <span class="operator">=</span> (Integer) template.convertSendAndReceive</span><br><span class="line">(exchange.getName(), <span class="string">&quot;rpc&quot;</span>, start++);</span><br><span class="line">System.out.println(<span class="string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="string">&quot;&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="a-note-on-rpcrpc的注意点"><a class="markdownIt-Anchor" href="#a-note-on-rpcrpc的注意点"></a> A note on RPC（RPC的注意点）</h4>
<p>Although RPC is a pretty common pattern in computing, it’s often criticised. The problems arise when a programmer is not aware whether a function call is local or if it’s a slow RPC. Confusions like that result in an unpredictable system and adds unnecessary complexity to debugging. Instead of simplifying software, misused RPC can result in unmaintainable spaghetti code.</p>
<p>虽然RPC在计算领域是很常见的模式，但它通常也是受争议的。但程序员不知道一个函数调用是本地的还是慢速的RPC时就会出现一些问题。像这样的混乱会导致不可预知的系统，而且会给调试增加不必要的复杂性。不恰当地使用RPC不仅不会简化程序，还会导致代码变得很难维护。</p>
<p>Bearing that in mind, consider the following advice:</p>
<p>记住这一点，然后考虑一下几点建议：</p>
<ul>
<li>Make sure it’s obvious which function call is local and which is remote.（确保哪个函数调用是本地的，哪个是远程的。）</li>
<li>Document your system. Make the dependencies between components clear.（为你的系统做好文档。清晰化组件间的依赖。）</li>
<li>Handle error cases. How should the client react when the RPC server is down for a long time?（处理好会发生错误的场景。但RPC服务端长时间挂掉时，客户端应该做出什么反应？）</li>
</ul>
<p>When in doubt avoid RPC. If you can, you should use an asynchronous pipeline - instead of RPC-like blocking, results are asynchronously pushed to a next computation stage.</p>
<p>当你无法对这些问题无法做出明确回答时，就不要使用RPC。如果可以的话，你应该使用异步pipeline，而不是类似于阻塞的RPC。使用异步pipeline，计算结果可以异步推入到下一个计算阶段。</p>
</blockquote>
<h3 id="callback-queue回调队列"><a class="markdownIt-Anchor" href="#callback-queue回调队列"></a> Callback queue（回调队列）</h3>
<p>In general doing RPC over RabbitMQ is easy. A client sends a request message and a server replies with a response message. In order to receive a response we need to send a ‘callback’ queue address with the request. Spring-amqp’s RabbitTemplate handles the callback queue for us when we use the above ‘convertSendAndReceive()’ method. There is no need to do any other setup when using the RabbitTemplate. For a thorough explanation please see <a href="http://docs.spring.io/spring-amqp/reference/htmlsingle/#request-reply">Request/Reply Message</a>.</p>
<p>一般情况下，在RabbitMQ上实现RPC挺简单的。客户端发送请求消息然后服务端返回一个响应消息。为了接收响应消息，我们必须传送一个用于处理请求的回调队列。在我们使用“convertSendAndReceive()”方法时，Spring-amqp框架的RabbitTemplate类为我们做好了回调队列的处理工作。使用RabbitTemplate类时无需在做其它配置。若想看完整的文档，请参阅<a href="https://legacy.gitbook.com/book/jiapengcai/rabbitmq/edit#">请求/发送消息</a>。</p>
<blockquote>
<h4 id="message-properties消息属性"><a class="markdownIt-Anchor" href="#message-properties消息属性"></a> Message properties（消息属性）</h4>
<p>The AMQP 0-9-1 protocol predefines a set of 14 properties that go with a message. Most of the properties are rarely used, with the exception of the following:</p>
<p>AMQP 0-9-1协议预定义了14个消息属性。大部分的属性都很少用到，除了以下几个：</p>
<ul>
<li>deliveryMode: Marks a message as persistent (with a value of 2) or transient (any other value). You may remember this property from the second tutorial.</li>
<li>deliveryMode：将消息标记为要持久化（此时属性值为2）或者瞬态（此时属性值为2以外的其它数字）。教程2里提到过这<br />
个属性，你应该还记得。</li>
<li>contentType: Used to describe the mime-type of the encoding. For example for the often used JSON encoding it is a good practice to set this property to: application/json.</li>
<li>contentType：用来描述编码的mime类型。例如，对于常用的JSON格式，最好将这个属性值设为application/json。</li>
<li>replyTo: Commonly used to name a callback queue.</li>
<li>replayTo：通常用来命名一个回调队列。</li>
<li>correlationId: Useful to correlate RPC responses with requests.</li>
<li>correlationId：该属性用来将RPC响应与请求进行关联。</li>
</ul>
</blockquote>
<h3 id="correlation-id关联id"><a class="markdownIt-Anchor" href="#correlation-id关联id"></a> Correlation Id（关联Id）</h3>
<p>Spring-amqp allows you to focus on the message style you’re working with and hide the details of message plumbing required to support this style. For example, typically the native client would create a callback queue for every RPC request. That’s pretty inefficient so an alternative is to create a single callback queue per client.</p>
<p>Spring-amqp能让你专注于正在处理的消息类型，并隐藏了支持该类型的消息所需的消息管道的实现细节。例如，通常情况下，本地客户端会为每个RPC请求都创建一个回调队列。这种做法效率很低，所以替换方案是每个客户端只创建一个回调队列。</p>
<p>That raises a new issue, having received a response in that queue it’s not clear to which request the response belongs. That’s when the correlationId property is used. Spring-amqp automatically sets a unique value for every request. In addition it handles the details of matching the response with the correct correlationId.</p>
<p>但这会导致一个新的问题，那就是，对于从这个队列里接收的响应，我们无法知道它对应的是哪个请求。这时候，correlationId就派上用场了。spring-amqp自动帮我们为每一个请求设好了唯一的correlationId值。而且，它还帮我们做好了将响应与correlationId进行匹配的细节。</p>
<p>One reason that spring-amqp makes rpc style easier is that sometimes you may want to ignore unknown messages in the callback queue, rather than failing with an error. It’s due to a possibility of a race condition on the server side. Although unlikely, it is possible that the RPC server will die just after sending us the answer, but before sending an acknowledgment message for the request. If that happens, the restarted RPC server will process the request again. The spring-amqp client handles the duplicate responses gracefully, and the RPC should ideally be idempotent.</p>
<p>spring-amqp使得rpc模式变得简单的一个原因是，有时你可能会想忽略回调队列里的一些未知消息，而不是抛出错误。这是因为服务端可能会出现竞争的情况。有可能RPC服务端在给我们发送完响应但却还没来得及发送确认消息时，它就挂了，虽然看起来不大像会这样。如果发生了这种情况，重启RPC服务端会继续再去处理这条请求。spring-amqp客户端会优雅地处理重复的响应，这种情况下，RPC应该是完美幂等的。</p>
<h3 id="summary总结"><a class="markdownIt-Anchor" href="#summary总结"></a> Summary（总结）</h3>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="image" /></p>
<p>Our RPC will work like this:</p>
<p>我们的RPC系统</p>
<p>1.The Tut6Config will setup a new DirectExchange and a client</p>
<p>在Tut6Config文件里将建立一个新的DirectExchange和一个客户端。</p>
<p>2.The client will leverage the convertSendAndReceive passing the exchange name, the routingKey, and the message.</p>
<p>客户端将使用convertSendAndReceive，并传入交换器名字，路由键和消息。</p>
<p>3.The request is sent to an rpc_queue(“tut.rpc”) queue.</p>
<p>请求被发送到用于rpc的队列里（“tut.rpc”）。</p>
<p>4.The RPC worker (aka: server) is waiting for requests on that queue. When a request appears, it performs the task and sends a message with the result back to the Client, using the queue from the replyTo field.</p>
<p>RPC工作者（也就是服务器）等待发送到队列里的请求。但一个请求出现时，它就执行任务，然后通过使用replyTo域里配置的队列将带有结果的消息发回给客户端。</p>
<p>5.The client waits for data on the callback queue. When a message appears, it checks the correlationId property. If it matches the value from the request it returns the response to the application. Again, this is done automagically via the RabbitTemplate.</p>
<p>客户端等待回调队列里的数据。当一条消息出现时，它会校验correlationId属性。如果属性值与请求匹配，它就将响应返回给应用。这个工作RabbitTemplate自动帮我们完成了。</p>
<h2 id="putting-it-all-together代码整合"><a class="markdownIt-Anchor" href="#putting-it-all-together代码整合"></a> Putting it all together（代码整合）</h2>
<p>The Fibonacci task is a @RabbitListener and is defined as:</p>
<p>计算斐波那契的任务用@RabbitListener进行标注，任务内容的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="type">return</span> <span class="variable">n</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="number">0</span> : n == <span class="number">1</span> ? <span class="number">1</span> : (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We declare our fibonacci function. It assumes only valid positive integer input. (Don’t expect this one to work for big numbers, and it’s probably the slowest recursive implementation possible).</p>
<p>我们声明了斐波那契函数。它假定输入的参数是有效的正整数。（不要期望它能用于大数的场景，而且这种方式是最低效的递归实现）。</p>
<p>The code for our <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut6/Tut6Config.java">Tut6Config</a> looks like this:</p>
<p><a href="https://legacy.gitbook.com/book/jiapengcai/rabbitmq/edit#">Tut6Config</a>的代码看起来是如下这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut6&quot;,&quot;rpc&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut6Config</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Profile(&quot;client&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> DirectExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;tut.rpc&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut6Client <span class="title function_">client</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut6Client</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;server&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;tut.rpc.requests&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> DirectExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;tut.rpc&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding</span><span class="params">(DirectExchange exchange, Queue queue)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;rpc&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut6Server <span class="title function_">server</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut6Server</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It setups up our profiles as “tut6” or “rpc”. It also setups a “client” profile with two beans; 1) the DirectExchange we are using and 2) the Tut6Client itself. We also configure the “server” profile with three beans, the “tut.rpc.requests” queue, the DirectExchange, which matches the client’s exchange, and the binding from the queue to the exchange with the “rpc” routing-key.</p>
<p>它建立了我们的配置组，叫“tut6”或者“rpc”。同时，还建立了一个“client”配置组，这个组里配置了两个bean：一个是我们将要用到的DirectExchange类型的交换器，一个是Tut6Client本身。我们还建立了一个“server”配置组，这个组里配置了三个bean：一个名为“tut.rpc.requests”的队列，一个与客户端交换器相匹配的DirectExchange类型的交换器，以及用名为“rpc”的路由键将队列和交换器的绑定器。</p>
<p>The server code is rather straightforward:</p>
<p>服务端代码更直观点：</p>
<p><a href="http://1.As">1.As</a> usual we start annotating our receiver method with a @RabbitListener and defining the queue its listening on.</p>
<p>像之前那样，我们先用@RabbitListener来注解我们的接收者方法，然后定义它要监听的队列。</p>
<p>2.Our fibanacci method calls fib() with the payload parameter and returns the result.</p>
<p>我们的斐波那契方法被命名为fib()，接收有效参数并返回结果。</p>
<p>The code for our RPC server <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut6/Tut6Server.java">Tut6Server.java</a>:</p>
<p>以下为我们的RPC服务端代码<a href="https://legacy.gitbook.com/book/jiapengcai/rabbitmq/edit#">Tut6Server.java</a>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.amqp.tutorials.tut6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut6Server</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;tut.rpc.requests&quot;)</span></span><br><span class="line">	<span class="comment">// @SendTo(&quot;tut.rpc.replies&quot;) used when the</span></span><br><span class="line">	<span class="comment">// client doesn&#x27;t set replyTo.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Received request for &quot;</span> + n);</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> fib(n);</span><br><span class="line">		System.out.println(<span class="string">&quot; [.] Returned &quot;</span> + result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">n</span> <span class="operator">=</span>= <span class="number">0</span> ? <span class="number">0</span> : n == <span class="number">1</span> ? <span class="number">1</span> : (fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The client code <a href="https://github.com/rabbitmq/rabbitmq-tutorials/blob/master/spring-amqp/src/main/java/org/springframework/amqp/tutorials/tut6/Tut6Client.java">Tut6Client</a> is as easy as the server:</p>
<p>客户端代码<a href="https://legacy.gitbook.com/book/jiapengcai/rabbitmq/edit#">Tut6Client</a>与服务端代码一样简单：</p>
<p>1.We autowire the RabbitTemplate and the DirectExchange bean as defined in the Tut6Config.</p>
<p>我们自动注入Tut6Config里定义的类型为RabbitTemplate和DirectExchange的bean。</p>
<p>2.We invoke template.convertSendAndReceive with the parameters exchange name, routing key and message.</p>
<p>我们调用template.convertSendAndReceive，传入的参数为交换器名字，路由键以及消息。</p>
<p>3.We print the result.</p>
<p>打印出结果。</p>
<p>Making the Client request is simply:</p>
<p>发起客户端请求也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut6Client</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DirectExchange exchange;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Requesting fib(&quot;</span> + start + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">response</span> <span class="operator">=</span> (Integer) template.convertSendAndReceive(exchange.getName(), <span class="string">&quot;rpc&quot;</span>, start++);</span><br><span class="line">		System.out.println(<span class="string">&quot; [.] Got &#x27;&quot;</span> + response + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using the project setup as defined in (see tutorial one) with <a href="http://start.spring.io">start.spring.io</a> and SpringInitialzr the preparing the runtime is the same as the other tutorials:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>We can start the server with:</p>
<p>我们可以用以下命令来启动服务端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=rpc,server</span><br><span class="line">--tutorial.client.duration=6000</span><br></pre></td></tr></table></figure>
<p>To request a fibonacci number run the client:</p>
<p>若要请求斐波那契数值，可以用以下命令来启动客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=rpc,server</span><br><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar</span><br><span class="line">--spring.profiles.active=rpc,client</span><br></pre></td></tr></table></figure>
<p>The design presented here is not the only possible implementation of a RPC service, but it has some important advantages:</p>
<p>以上展示的设计不仅仅是实现RPC服务的一种方式，而且还有一些重要的优点：</p>
<p>1.If the RPC server is too slow, you can scale up by just running another one. Try running a second RPC Server in a new console.</p>
<p>如果RPC服务端太慢，你可以仅仅通过额外再运行一个服务端来增大其规模。可以尝试着在新的控制台里运行第二个RPC服务端。</p>
<p>2.On the client side, the RPC requires sending and receiving only one message with one method. No synchronous calls like queueDeclare are required. As a result the RPC client needs only one network round trip for a single RPC request.</p>
<p>在客户端这一边，RPC要求只能一个方法里发送和接收一条消息。不需要像queueDelare那样的同步调用。于是，对于一个RPC请求，RPC客户端只需一个网络回路。</p>
<p>Our code is still pretty simplistic and doesn’t try to solve more complex (but important) problems, like:</p>
<p>我们的代码仍然很简单，而且没有处理很多复杂（但重要）的问题，像：</p>
<p>1.How should the client react if there are no servers running?</p>
<p>如果没有服务端正在运行，客户端应该做出什么反应？</p>
<p>2.Should a client have some kind of timeout for the RPC?</p>
<p>客户端需要为RPC做超时处理吗？</p>
<p>3.If the server malfunctions and raises an exception, should it be forwarded to the client?</p>
<p>如果服务端出现故障并引起了异常，它是否应该告知客户端？</p>
<p>4.Protecting against invalid incoming messages (eg checking bounds, type) before processing.</p>
<p>在处理进来的消息之前先处理掉无效的消息（如校验边界，类型）。</p>
<blockquote>
<p>If you want to experiment, you may find the <a href="https://www.rabbitmq.com/management.html">management UI</a> useful for viewing the queues.</p>
<p>如果你想做些实验，可以通过<a href="https://legacy.gitbook.com/book/jiapengcai/rabbitmq/edit#">管理界面</a>来查看队列，你会发现它很有用的。</p>
</blockquote>
<p>There is one other nice feature of RabbitMQ. It is featured as a supported tile on Pivotal Cloud Foundry (PCF) as a service.</p>
<p>RabbitMQ还有另一个很棒的特性。它作为服务在Pivotal Cloud Foundry（PCF）上被支持。</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（三）--发布/订阅</title>
    <url>/posts/14583/</url>
    <content><![CDATA[<h1 id="publishsubscribe发布订阅"><a class="markdownIt-Anchor" href="#publishsubscribe发布订阅"></a> Publish/Subscribe（发布/订阅）</h1>
<p>In the first tutorial we showed how to use <a href="http://start.spring.io">start.spring.io</a> to leverage Spring Initializr to create a project with the RabbitMQ starter dependency for create spring-amqp applications.</p>
<p>在第一个教程中，我们展示了如何通过<a href="https://start.spring.io/">start.spring.io</a>上的Spring初始化手脚架来创建一个包含了RabbitMQ starter依赖的项目，并以此创建基于spring-amqp的应用。</p>
<p>In the previous tutorial we created a new package (tut2) to place our config, sender and receiver and created a work queue with two consumers. The assumption behind a work queue is that each task is delivered to exactly one worker.</p>
<p>在上一个教程当中，我们创建了一个新的包（tut2）来放置我们的配置类，发送者类和接收者类，并创建了一个对应着两个消费者的队列。工作队列背后的原理假设是，每个任务都发送给某个恰当的工作者。</p>
<p>In this part we’ll implement the fanout pattern to deliver a message to multiple consumers. This pattern is known as “publish/subscribe” and is implementing by configuring a number of beans in our Tut3Config file.</p>
<p>在这部分教程中，我们将实现广播模式（fanout pattern），从而将一条消息发送给多个消费者。这个模式被称为“发布/订阅”，我们将在Tut3Config文件里配置一系列bean来实现这个模式。</p>
<span id="more"></span>
<p>Essentially, published messages are going to be broadcast to all the receivers.</p>
<p>本质上，发布的消息将被广播给所有的接收者。</p>
<h2 id="exchanges交换器"><a class="markdownIt-Anchor" href="#exchanges交换器"></a> Exchanges（交换器）</h2>
<p>In previous parts of the tutorial we sent and received messages to and from a queue. Now it’s time to introduce the full messaging model in Rabbit.</p>
<p>在前面的教程里，我们通过一个队列来发送消息，并从这个队列里接收消息。接下来我们将介绍RabbitMQ完整的消息队列模型。</p>
<p>Let’s quickly go over what we covered in the previous tutorials:</p>
<p>我们先来快速过一遍前面的教程里涉及到的内容：</p>
<p>A <em>producer</em> is a user application that sends messages.</p>
<p>生产者是值发送消息的应用。</p>
<p>A <em>queue</em> is a buffer that stores messages.</p>
<p>队列是指存储消息的缓存。</p>
<p>A <em>consumer</em> is a user application that receives messages.</p>
<p>消费者是指接收消息的应用。</p>
<p>The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue. Actually, quite often the producer doesn’t even know if a message will be delivered to any queue at all.</p>
<p>RabbitMQ的消息队列模型的核心概念是：生产者从不直接往队列里发送任何消息。实际上，多数情况下生产者甚至不知道消息是否会被发送到队列里。</p>
<p>Instead, the producer can only send messages to an <em>exchange</em>. An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues. The exchange must know exactly what to do with a message it receives. Should it be appended to a particular queue? Should it be appended to many queues? Or should it get discarded. The rules for that are defined by the <em>exchange type</em>.</p>
<p>与此相反，生产者只能将消息发送到一个交换器里。交换器做的事情很简单。一方面它接收生产者发送过来的消息，另一方面它将收到的消息推入队列里。交换器必须明确对于收到的消息它该怎么处理。这条消息是否应该附加到某个特定的队列后面？这条消息是否应该附加到多个队列后面？这条消息是否应该被丢弃？这些规则都由交换器类型（exchange type）来定义。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/exchanges.png" alt="image" /></p>
<p>There are a few exchange types available: direct, topic, headers and fanout. We’ll focus on the last one – the fanout. Let’s configure a bean to describe an exchange of this type, and call it tut.fanout:</p>
<p>有四种交换器类型可供我们选择：直连交换器（direct），主题交换器（topic），头部交换器（headers）和广播交换器（fanout）。我们将专注于最后一个——广播交换器。我们先配置一个bean来描述这种类型的交换器，并把这个交换器命名为tut.fanout：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut3&quot;, &quot;pub-sub&quot;, &quot;publish-subscribe&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut3Config</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> FanoutExchange <span class="title function_">fanout</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;tut.fanout&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;receiver&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReceiverConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding1</span><span class="params">(FanoutExchange fanout, Queue autoDeleteQueue1)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(fanout);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Binding <span class="title function_">binding2</span><span class="params">(FanoutExchange fanout, Queue autoDeleteQueue2)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue2).to(fanout);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut3Receiver <span class="title function_">receiver</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut3Receiver</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;sender&quot;)</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Tut3Sender <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut3Sender</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We ollow the same approach as in the previous two tutorials. We create three profiles, the tutorial (“tut3”, “pub-sub”, or “publish-subscribe”). They are all synonyms for running the fanout profile tutorial. Next we configure the FanoutExchange as a bean. Within the “receiver” (Tut3Receiver) file we define four beans: two autoDeleteQueues or AnonymousQueues and two bindings to bind those queues to the exchange.</p>
<p>我们采用了与前面两个教程相同的方式。我们创建了三个配置组，“tut3”，“pub-sub”，或者叫“publish-subscribe”。这三个配置在运行本教程时都是等效的。接下来我们会配置一个类型为FanoutExchange的bean。在“receiver”配置组里，我们定义了四个bean：两个AnonymousQueue类型的队列，即autoDeleteQueue1和autoDeleteQueue2，及两个将队列绑定到交换器的绑定器（binding）。</p>
<p>The fanout exchange is very simple. As you can probably guess from the name, it just broadcasts all the messages it receives to all the queues it knows. And that’s exactly what we need for fanning out our messages.</p>
<p>广播交换器很简单。你大概可以从名字上看出，它只是将所有它接收到的消息广播给它所知道的所有队列。广播消息这一点正是我们需要的。</p>
<blockquote>
<h4 id="listing-exchanges列出所有的交换器"><a class="markdownIt-Anchor" href="#listing-exchanges列出所有的交换器"></a> Listing exchanges（列出所有的交换器）</h4>
<p>To list the exchanges on the server you can run the ever useful rabbitmqctl:</p>
<p>你可以通过运行强大的rabbitmqctl来列出服务器上所有的交换器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_exchanges</span><br></pre></td></tr></table></figure>
<p>In this list there will be some amq.* exchanges and the default (unnamed) exchange. These are created by default, but it is unlikely you’ll need to use them at the moment.</p>
<p>在这个列表里，会出现一些类似于amq.开头的交换器，以及默认的（未命名）交换器。这些交换器都默认被创建，但这时你不一定会用到它们。</p>
<h4 id="nameless-exchange匿名交换器"><a class="markdownIt-Anchor" href="#nameless-exchange匿名交换器"></a> Nameless exchange（匿名交换器）</h4>
<p>In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues. That was possible because we were using a default exchange, which we identify by the empty string (“”).</p>
<p>在前面的教程里，我们虽然对交换器一无所知，但依旧能够将消息发送到队列里。之所以能这样是因为我们使用了一个默认的交换器，而这个默认的交换器则用空字符串（“”）来标识。</p>
<p>Recall how we published a message before:</p>
<p>回顾一下我们之前是如何发布消息的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template.convertAndSend(fanout.getName(), &quot;&quot;, message);</span><br></pre></td></tr></table></figure>
<p>The first parameter is the the name of the exchange that was autowired into the sender. The empty string denotes the default or <em>nameless</em> exchange: messages are routed to the queue with the name specified by routingKey, if it exists.</p>
<p>第一个参数是被自动注入到发送者类的交换器的名字。空字符串表示该交换器是默认或者匿名的：如果路由键存在的话，消息则通过这个路由键名被路由到某个队列里：</p>
</blockquote>
<p>Now, we can publish to our named exchange instead:</p>
<p>现在，我们可以将信息发布到我们命名好的交换器里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FanoutExchange fanout; <span class="comment">// configured in Tut3Config above</span></span><br><span class="line"></span><br><span class="line">template.convertAndSend(fanout.getName(), <span class="string">&quot;&quot;</span>, message);</span><br></pre></td></tr></table></figure>
<p>From now on the fanout exchange will append messages to our queue.</p>
<p>从现在开始，广播交换器将会把信息附加到我们的队列里。</p>
<h2 id="temporary-queues临时队列"><a class="markdownIt-Anchor" href="#temporary-queues临时队列"></a> Temporary queues（临时队列）</h2>
<p>As you may remember previously we were using queues which had a specified name (remember hello). Being able to name a queue was crucial for us – we needed to point the workers to the same queue. Giving a queue a name is important when you want to share the queue between producers and consumers.</p>
<p>就如你记住的那样，之前我们都是使用具有指定名字的队列（前面的教程里用的是hello）。命名一个队列对于我们是至关重要的——我们需要将工作者指到相同的队列上去。当你想要在生产者和消费者之间共享队列时，为队列指定一个名字是很重要的。</p>
<p>But that’s not the case for our fanout example. We want to hear about all messages, not just a subset of them. We’re also interested only in currently flowing messages not in the old ones. To solve that we need two things.</p>
<p>但在我们在用广播交换器时则不用这么做。我们需要收到所有的消息，而不仅仅是部分。我们也只关心当前的消息，而不是旧的那一部分。为了解决这些需求，我们需要做两件事。</p>
<p>Firstly, whenever we connect to Rabbit we need a fresh, empty queue. To do this we could create a queue with a random name, or, even better - let the server choose a random queue name for us.</p>
<p>首先，无论什么时候连接RabbitMQ，我们都需要一个新的而且是空的队列。为了做到这点，我们可以创建一个名字随机的队列，或者更好的做法是，让服务器为我们选一个随机的队列。</p>
<p>Secondly, once we disconnect the consumer the queue should be automatically deleted. To do this with the spring-amqp client, we defined an <em>AnonymousQueue</em>, which creates a non-durable, exclusive, autodelete queue with a generated name:</p>
<p>然后，一旦我们断开了消费者，队列应该被自动删除。我们可以通过spring-amqp客户端来做到这点，在配置里我们定义了一个AnonymousQueue类型的队列，它的名字是由客户端生成的，而且是非持久的，独占的，自动删除的队列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">autoDeleteQueue2</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnonymousQueue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At this point our queue names contain a random queue names. For example it may look like amq.gen-JzTY20BRgKO-HjmUJj0wLg.</p>
<p>此时我们的队列名字是随机的。例如，队列名字可能看起来是这样的：amq.gen-JzTY20BRgKO-HjmUJj0wLg。</p>
<h2 id="bindings绑定器"><a class="markdownIt-Anchor" href="#bindings绑定器"></a> Bindings（绑定器）</h2>
<p><img src="https://www.rabbitmq.com/img/tutorials/bindings.png" alt="image" /></p>
<p>We’ve already created a fanout exchange and a queue. Now we need to tell the exchange to send messages to our queue. That relationship between exchange and a queue is called a <em>binding</em>. In the above Tut3Config you can see that we have two bindings, one for each AnonymousQueue.</p>
<p>我们已经创建了一个广播交换器和一个队列。现在我们需要让交换器将消息发送到我们的队列里。用于连接交换器和队列的对象被称为绑定器（binding）。在上面的Tut3Config里，你会发现我们配置了两个绑定器，分别对应一个AnonymousQueue。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">binding1</span><span class="params">(FanoutExchange fanout, Queue autoDeleteQueue1)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(autoDeleteQueue1).to(fanout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="listing-bindings列出所有的绑定"><a class="markdownIt-Anchor" href="#listing-bindings列出所有的绑定"></a> Listing bindings（列出所有的绑定）</h4>
<p>You can list existing bindings using, you guessed it,</p>
<p>你可以通过使用某个命令来列出所有的绑定，猜是哪个，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_bindings</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="putting-it-all-together代码整合"><a class="markdownIt-Anchor" href="#putting-it-all-together代码整合"></a> Putting it all together（代码整合）</h2>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-three-overall.png" alt="image" /></p>
<p>The producer program, which emits messages, doesn’t look much different from the previous tutorial. The most important change is that we now want to publish messages to our fanout exchange instead of the nameless one. We need to supply a routingKey when sending, but its value is ignored for fanout exchanges. Here goes the code for tut3.Sender.java program:</p>
<p>本教程里用于生产消息的生产者程序看起来与前面教程里的生产者程序没什么区别。最大的变化是我们现在想把消息发布到广播交换器里去，而不是匿名交换器。发送消息时我们需要用到路由键（routingKey），但对于广播交换器，它的值是被忽略的。以下是本教程的发送者类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut3Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> FanoutExchange fanout;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">dots</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (dots++ == <span class="number">3</span>) &#123;</span><br><span class="line">			dots = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dots; i++) &#123;</span><br><span class="line">			builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		builder.append(Integer.toString(++count));</span><br><span class="line">		<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">		template.convertAndSend(fanout.getName(), <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you see, we leverage the beans from the Tut3Config file and autowire in the RabbitTemplate along with our configured FanoutExchange. This step is necessary as publishing to a non-existing exchange is forbidden.</p>
<p>就如你所看到的那样，我们利用Tut3Config文件里配置好的bean，并自动注入RabbitTemplate和FanoutExchange。这一步是很有必要的，因为发布消息到不存在的交换器是不允许的。</p>
<p>The messages will be lost if no queue is bound to the exchange yet, but that’s okay for us; if no consumer is listening yet we can safely discard the message.</p>
<p>如果没有队列绑定到交换器，那么消息将会丢失，但这对于我们来说是可接受的；如果没有消费者在监听队列，那么即使消息丢失也是安全的。</p>
<p>The code forTut3Receiver.java:</p>
<p>以下是发送者类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut3Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue1.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive1</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;#&#123;autoDeleteQueue2.name&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive2</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		receive(in, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String in, <span class="type">int</span> receiver)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">		watch.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Received &#x27;&quot;</span> + in + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		doWork(in);</span><br><span class="line">		watch.stop();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + receiver + <span class="string">&quot; [x] Done in &quot;</span> + watch.getTotalTimeSeconds() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compile as before and we’re ready to execute the fanout sender and receiver.</p>
<p>像之前那样编译，我们已经准备好要运行基于广播的发送者程序和接收者程序了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure>
<p>And of course, to execute the tutorial do the following:</p>
<p>当然，若要运行示例代码，我们还要执行以下命令行语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar --spring.profiles.active=pub-sub,receiver</span><br><span class="line">--tutorial.client.duration=60000</span><br><span class="line">java -jar target/rabbit-tutorials-1.7.1.RELEASE.jar --spring.profiles.active=pub-sub,sender</span><br><span class="line">--tutorial.client.duration=60000</span><br></pre></td></tr></table></figure>
<p>Using rabbitmqctl list_bindings you can verify that the code actually creates bindings and queues as we want. With two ReceiveLogs.java programs running you should see something like:</p>
<p>使用rabbitmqctl list_bindings语句你可以验证上述代码的确按照我们所想的创建了绑定和队列。执行语句后你会看到类似于如下的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_bindings</span><br><span class="line">tut.fanout exchange 8b289c9c-a1eb-4a3a-b6a9-163c4fdcb6c2 queue []</span><br><span class="line">tut.fanout exchange d7e7d193-65b1-4128-a532-466a5256fd31 queue []</span><br></pre></td></tr></table></figure>
<p>The interpretation of the result is straightforward: data from exchange logs goes to two queues with server-assigned names. And that’s exactly what we intended.</p>
<p>打印结果的意思很明显：从交换器过来的消息进入了两个由服务器命名的队列。这正是我们想要的结果。</p>
<p>To find out how to listen for a subset of messages, let’s move on to tutorial 4.</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ Spring-AMQP官方教程（二）--工作队列</title>
    <url>/posts/13955/</url>
    <content><![CDATA[<h1 id="2-工作队列work-queues"><a class="markdownIt-Anchor" href="#2-工作队列work-queues"></a> 2 工作队列（Work Queues）</h1>
<p><img src="https://www.rabbitmq.com/img/tutorials/python-two.png" alt="image" /></p>
<p>In the first tutorial we wrote programs to send and receive messages from a named queue. In this one we’ll create a <em>Work</em> <em>Queue</em> that will be used to distribute time-consuming tasks among multiple workers.</p>
<p>在第一个教程中，我们编写了两个程序，一个用于往一个命名了的队列发送消息，另一个从这个队列里接收消息。在本教程里，我们将创建一个工作队列（Work Queue），它将被用来在多个工作者之间分发耗时任务。</p>
<span id="more"></span>
<p>The main idea behind Work Queues (aka: <em>Task Queues</em>) is to avoid doing a resource-intensive task immediately and having to wait for it to complete. Instead we schedule the task to be done later. We encapsulate a <em>task</em> as a message and send it to a queue. A worker process running in the background will pop the tasks and eventually execute the job. When you run many workers the tasks will be shared between them.</p>
<p>工作队列（也叫做任务队列）背后的主要目的是为了避免立即执行资源密集型的任务以及避免必须等待任务完成的情况，相反，它计划着让这些任务可以留到后面去执行。我们将任务分装成消息，并将它发送到队列里。运行在后台的工作进程将取出任务并最终执行它。如果你运行了多个工作进程，那么所有的任务将被它们共享。</p>
<p>This concept is especially useful in web applications where it’s impossible to handle a complex task during a short HTTP request window.</p>
<p>对于web应用，这个概念特别有用，因为web应用无法在短短的HTTP请求窗口内处理复杂的任务。</p>
<h3 id="preparation准备工作"><a class="markdownIt-Anchor" href="#preparation准备工作"></a> Preparation（准备工作）</h3>
<p>In the previous part of this tutorial we sent a message containing “Hello World!”. Now we’ll be sending strings that stand for complex tasks. We don’t have a real-world task, like images to be resized or pdf files to be rendered, so let’s fake it by just pretending we’re busy - by using the Thread.sleep() function. We’ll take the number of dots in the string as its complexity; every dot will account for one second of “work”. For example, a fake task described by Hello… will take three seconds.</p>
<p>在教程1里，我们实现了如何发送包含“Hello World!”的消息。现在，我们将发送表示复杂任务的字符串。由于我们没有真实的任务，如调整图片大小或者渲染pdf文件，所以我们通过使用Thread.sleep()函数来模拟繁忙的耗时任务。我们将在字符串中用点号的个数来表示复杂度，点号的个数表示整个任务执行秒的秒数。例如，Hello…表示模拟任务需要执行三秒。</p>
<p>Please see the setup in first tutorial if you have not setup the project. We will follow the same pattern as in the first tutorial: create a package (tut2) and create a Tut2Config, Tut2Receiver, and Tut2Sender. Start by creating a new package (tut2) where we’ll place our three classes. In the configuration class we setup two profiles, the label for the tutorial (“tut2”) and the name of the pattern (“work-queues”). We leverage spring to expose the queue as a bean. We setup the receiver as a profile and define two beans to correspond to the workers in our diagram above： receiver1 and receiver2. Finally, we define a profile for the sender and define the sender bean. The configuration is now done.</p>
<p>如果你还未建立配置好项目，请见教程1的配置过程。我们将采用与教程1相同的方式，新建一个包目录（tut2）并创建一个名为Tut2Config的配置类，一个名为Tut2Receiver的消息接收类，以及一个名为Tut2Sender的消息发送类。首先新建包目录（tut2），我们将在这个包下面放刚说到的那三个类。在配置类里，我们将配置两个配置组，一个作为当前教程的标签（“tut2”），一个作为当前RabbitMQ使用模式的名字（“work-queue”）。我们利用Spring框架将队列暴露为一个bean。我们设置一个接受者配置组，并定义两个bean来对应于上面图中的两个消费者：receiver1和receiver2。最后，我们会定义一个发送者配置组，并定义作为发送者的bean。这样配置就结束了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;tut2&quot;, &quot;work-queues&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut2Config</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;receiver&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReceiverConfig</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut2Receiver <span class="title function_">receiver1</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut2Receiver</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> Tut2Receiver <span class="title function_">receiver2</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut2Receiver</span>(<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Profile(&quot;sender&quot;)</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Tut2Sender <span class="title function_">sender</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tut2Sender</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sender发送者"><a class="markdownIt-Anchor" href="#sender发送者"></a> Sender（发送者）</h3>
<p>We will modify the sender to provide a means for identifying whether its a longer running task by appending a dot to the message in a very contrived fashion using the same method on the RabbitTemplate to publish the message, convertAndSend. The documentation defines this as, “Convert a Java object to an Amqp Message and send it to a default exchange with a default routing key.”</p>
<p>我们将对发送者类进行修改，在发送方法中，通过人为地在消息后面添加点号来识别当前任务是否耗时，并依旧使用RabbitTemplate的convertAndSend方法来发布消息。文档把convertAndSend方法定义为，“将一个Java对象转换成一个Amqp消息，并用一个默认路由键（routing key）将其发送到一个默认的exchange里。”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut2Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate template;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Queue queue;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">dots</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Scheduled(fixedDelay = 1000, initialDelay = 500)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (dots++ == <span class="number">3</span>) &#123;</span><br><span class="line">			dots = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dots; i++) &#123;</span><br><span class="line">			builder.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		builder.append(Integer.toString(++count));</span><br><span class="line">		<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">		template.convertAndSend(queue.getName(), message);</span><br><span class="line">		System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="receiver接收者"><a class="markdownIt-Anchor" href="#receiver接收者"></a> Receiver（接收者）</h3>
<p>Our receiver, Tut2Receiver, simulates an arbitary length for a fake task in the doWork() method where the number of dots translates into the number of seconds the work will take. Again, we leverage a @RabbitListener on the “hello” queue and a @RabbitHandler to receive the message. The instance that is consuming the message is added to our monitor to show which instance, the message and the length of time to process the message.</p>
<p>我们的接收者类，Tut2Receiver，在doWork()方法里根据消息所带点号的个数，将其转换成任务所需消耗的秒数，以此模拟了任意任务的长度。同样地，我们对“hello”队列使用了@RabbitListener注解，并通过@RabbitHandler注解来接收消息。同时，用一个编号来标识正在消费消息的实例，并将它加入我们的监控中，最终打印出实例编号，消息内容以及处理消息所耗费的时长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tut2Receiver</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> instance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Tut2Receiver</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.instance = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RabbitHandler</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">		watch.start();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + <span class="built_in">this</span>.instance +</span><br><span class="line">		<span class="string">&quot; [x] Received &#x27;&quot;</span> + in + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		doWork(in);</span><br><span class="line">		watch.stop();</span><br><span class="line">		System.out.println(<span class="string">&quot;instance &quot;</span> + <span class="built_in">this</span>.instance +</span><br><span class="line">		<span class="string">&quot; [x] Done in &quot;</span> + watch.getTotalTimeSeconds() + <span class="string">&quot;s&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">(String in)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">char</span> ch : in.toCharArray()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="putting-it-all-together代码整合"><a class="markdownIt-Anchor" href="#putting-it-all-together代码整合"></a> Putting it all together（代码整合）</h3>
<p>Compile them using mvn package and run with the following options</p>
<p>使用mvn package来编译上述代码，并在运行时添加下面的命令行参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line"></span><br><span class="line">java -jar target/rabbitmq-amqp-tutorials-0.0.1-SNAPSHOT.jar --spring.profiles.active=work-queues,receiver</span><br><span class="line">java -jar target/rabbitmq-amqp-tutorials-0.0.1-SNAPSHOT.jar --spring.profiles.active=work-queues,sender</span><br></pre></td></tr></table></figure>
<p>The output of the sender should look something like:</p>
<p>发送者类的输出看起来应该是类似于这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ready ... running for 10000ms</span><br><span class="line">[x] Sent &#x27;Hello.1&#x27;</span><br><span class="line">[x] Sent &#x27;Hello..2&#x27;</span><br><span class="line">[x] Sent &#x27;Hello...3&#x27;</span><br><span class="line">[x] Sent &#x27;Hello.4&#x27;</span><br><span class="line">[x] Sent &#x27;Hello..5&#x27;</span><br><span class="line">[x] Sent &#x27;Hello...6&#x27;</span><br><span class="line">[x] Sent &#x27;Hello.7&#x27;</span><br><span class="line">[x] Sent &#x27;Hello..8&#x27;</span><br><span class="line">[x] Sent &#x27;Hello...9&#x27;</span><br><span class="line">[x] Sent &#x27;Hello.10&#x27;</span><br></pre></td></tr></table></figure>
<p>And the output from the workers should look something like:</p>
<p>而工作者类的输出看起来应该是类似于这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ready ... running for 10000ms</span><br><span class="line">instance 1 [x] Received &#x27;Hello.1&#x27;</span><br><span class="line">instance 2 [x] Received &#x27;Hello..2&#x27;</span><br><span class="line">instance 1 [x] Done in 1.001s</span><br><span class="line">instance 1 [x] Received &#x27;Hello...3&#x27;</span><br><span class="line">instance 2 [x] Done in 2.004s</span><br><span class="line">instance 2 [x] Received &#x27;Hello.4&#x27;</span><br><span class="line">instance 2 [x] Done in 1.0s</span><br><span class="line">instance 2 [x] Received &#x27;Hello..5&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="message-acknowledgment消息确认"><a class="markdownIt-Anchor" href="#message-acknowledgment消息确认"></a> Message acknowledgment（消息确认）</h3>
<p>Doing a task can take a few seconds. You may wonder what happens if one of the consumers starts a long task and dies with it only partly done. Spring AMQP by default takes a conservative approach to <a href="https://www.rabbitmq.com/confirms.html">message acknowledgement</a>. If the listener throws an exception the container calls:</p>
<p>完成一个任务需要耗费几秒。对于一个开始了长任务的消费者，你可能会想知道，当它只完成了部分任务就挂掉时发生了什么。Spring AMQP默认采用保守的方式来进行<a href="https://www.rabbitmq.com/confirms.html">消息确认</a>。如果监听器抛出了一个异常，那么容器会调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicReject(deliveryTag, requeue)</span><br></pre></td></tr></table></figure>
<p>Requeue is true by default unless you explicitly set:</p>
<p>requeue（重入队列）默认为true，除非你显示地将其设置为false：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaultRequeueRejected=false</span><br></pre></td></tr></table></figure>
<p>or the listener throws an AmqpRejectAndDontRequeueException. This is typically the bahavior you want from your listener. In this mode there is no need to worry about a forgotten acknowledgement. After processing the message the listener calls:</p>
<p>否则监听器抛出AmqpRejectAndDontRequeueException异常。这通常会是你想要监听器的行为。在这种模式下，无需担心一个被忘记了的确认。在处理完消息后，监听器会调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicAck()</span><br></pre></td></tr></table></figure>
<p>Acknowledgement must be sent on the same channel the delivery it is for was received on. Attempts to acknowledge using a different channel will result in a channel-level protocol exception. See the <a href="https://www.rabbitmq.com/confirms.html">doc guide on confirmations</a> to learn more. Spring AMQP generally takes care of this but when used in combination with code that uses RabbitMQ Java client directly, this is something to keep in mind.</p>
<p>消息确认必须在与接收信息相同的通道（channel）上进行发送。试图使用不同的通道来进行确认将导致通道级别的协议异常。若想更详细了解，可以参阅<a href="https://www.rabbitmq.com/confirms.html">关于消息确认的文档指南</a>。Spring AMQP一般都会处理好这种问题，但与直接使用RabbitMQ的Java客户端的代码结合使用时，这点要小心。</p>
<blockquote>
<h4 id="forgotten-acknowledgment被遗忘的确认"><a class="markdownIt-Anchor" href="#forgotten-acknowledgment被遗忘的确认"></a> Forgotten acknowledgment（被遗忘的确认）</h4>
<p>It’s a common mistake to miss the basicAck and spring-amqp helps to avoid this through its default configuraiton. The consequences are serious. Messages will be redelivered when your client quits (which may look like random redelivery), but RabbitMQ will eat more and more memory as it won’t be able to release any unacked messages.</p>
<p>忘记调用basciAck方法是常见的一个错误，spring-amqp通过它的默认配置来避免它。这个错误的后果是很严重的。当你的客户端退出后，消息会被重复发送（看起来就像是随机重发），但RabbitMQ将吃掉越来越多的内存，因为它无法释放任何未确认的消息。</p>
<p>In order to debug this kind of mistake you can use rabbitmqctl to print the messages_unacknowledged field:</p>
<p>为了调试这种错误，你可以使用rabbitmqctl来打印messages_unacknowledged域：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged</span><br></pre></td></tr></table></figure>
<p>On Windows, drop the sudo:</p>
<p>在Windows环境下，去掉sudo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rabbitmqctl.bat list_queues name messages_ready messages_unacknowledged</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="message-durability消息持久性"><a class="markdownIt-Anchor" href="#message-durability消息持久性"></a> Message durability（消息持久性）</h3>
<p>With spring-amqp there are reasonable default values in the MessageProperties that account for message durability. In particular you can check the table for <a href="http://docs.spring.io/spring-amqp/reference/htmlsingle/#_common_properties">common properties</a>. You’ll see two relevant to our discussion here on durability:</p>
<p>对于spring-amqp，消息属性配置里有很多合理的默认值，这些默认值共同决定了消息的持久性。你可以查阅<a href="http://docs.spring.io/spring-amqp/reference/htmlsingle/#_common_properties">常用属性表</a>。你将会看到与我们正在讨论的消息持久性相关的两个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Property</th>
<th style="text-align:left">default</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">durable</td>
<td style="text-align:left">true</td>
<td style="text-align:left">When declareExchange is true the durable flag is set to this value</td>
</tr>
<tr>
<td style="text-align:left">deliveryMode</td>
<td style="text-align:left">PERSISTENT</td>
<td style="text-align:left">PERSISTENT or NON_PERSISTENT to determine whether or not RabbitMQ should persist the messages</td>
</tr>
</tbody>
</table>
<blockquote>
<h4 id="note-on-message-persistence关于消息持久化要注意的地方"><a class="markdownIt-Anchor" href="#note-on-message-persistence关于消息持久化要注意的地方"></a> Note on message persistence（关于消息持久化要注意的地方）</h4>
<p>Marking messages as persistent doesn’t fully guarantee that a message won’t be lost. Although it tells RabbitMQ to save the message to disk, there is still a short time window when RabbitMQ has accepted a message and hasn’t saved it yet. Also, RabbitMQ doesn’t do fsync(2) for every message – it may be just saved to cache and not really written to the disk. The persistence guarantees aren’t strong, but it’s more than enough for our simple task queue. If you need a stronger guarantee then you can use publisher confirms.</p>
<p>将消息标记为持久化并不能完全保证消息将不会丢失。虽然它告诉RabbitMQ要将消息保存到磁盘，但当RabbitMQ接收了某条消息并且还没有保存该消息时，仍有一个小的时间窗口。而且，RabbitMQ不会为每条消息都进行fsync操作——它可能仅仅只是将其缓存起来，但并没有真的将消息写入磁盘。这么做虽然无法完全保证持久化，但对于我们简单的任务队列来说，这已经很足够了。如果你需要完全保证持久化，那么你可以使用发布者确认。</p>
</blockquote>
<h3 id="fair-dispatch-vs-round-robin-dispatching公平调度vs循环调度"><a class="markdownIt-Anchor" href="#fair-dispatch-vs-round-robin-dispatching公平调度vs循环调度"></a> Fair dispatch vs Round-robin dispatching（公平调度vs循环调度）</h3>
<p>By default, RabbitMQ will send each message to the next consumer, in sequence. On average every consumer will get the same number of messages. This way of distributing messages is called round-robin. In this mode dispatching doesn’t necessarily work exactly as we want. For example in a situation with two workers, when all odd messages are heavy and even messages are light, one worker will be constantly busy and the other one will do hardly any work. Well, RabbitMQ doesn’t know anything about that and will still dispatch messages evenly.</p>
<p>默认情况下，RabbitMQ将把每一条消息按顺序逐一发送给下一个消费者。每个消费者都将被平均分到相同的个数的消息。这种消息分派方式被称为循环调度。这种调度模式有时无法完全满足我们的需求。例如，假设有两个工作者，第奇数条消息是重任务，第偶数条消息是轻任务，那么其中一个工作者将会总是很繁忙，而另一个工作者则有可能没什么事做。然而，RabbitMQ并不知道这个状况，并且仍然会这么均匀地分发消息。</p>
<p>This happens because RabbitMQ just dispatches a message when the message enters the queue. It doesn’t look at the number of unacknowledged messages for a consumer. It just blindly dispatches every n-th message to the n-th consumer.</p>
<p>会发生这个情况是因为，当消息进入队列时，RabbitMQ仅仅是将消息分派出去。它不会去看某个消费者未确认的消息的数量。它只是盲目地将消息均匀分派给各个消费者。</p>
<p>However, “Fair dispatch” is the default configuration for spring-amqp. The SimpleMessageListenerContainer defines the value for DEFAULT_PREFETCH_COUNT to be 1. If the DEFAULT_PREFECTH_COUNT were set to 0 the behavior would be round robin messaging as described above.</p>
<p>然而，“公平调度”是spring-amqp的默认配置。SimpleMessageListenerContainer类将DEFAULT_PREFETCH_COUNT的值定义为1。如果DEFAULT_PREFETCH_COUNT的值被设置为0，那么调度方式将变成循环调用。</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="image" /></p>
<p>However, with the prefetchCount set to 1 by default, this tells RabbitMQ not to give more than one message to a worker at a time. Or, in other words, don’t dispatch a new message to a worker until it has processed and acknowledged the previous one. Instead, it will dispatch it to the next worker that is not still busy.</p>
<p>然而，prefetchCount的值默认设为1，这告诉RabbitMQ不要同时将多个消息分派给一个工作者。换句话说，在某个工作者处理完一条消息并确认它之前，RabbitMQ不会给该工作者分派新的消息，而是将新的消息分派给下一个不是很繁忙的工作者。</p>
<blockquote>
<h4 id="note-about-queue-size关于队列大小需要注意的地方"><a class="markdownIt-Anchor" href="#note-about-queue-size关于队列大小需要注意的地方"></a> Note about queue size（关于队列大小需要注意的地方）</h4>
<p>If all the workers are busy, your queue can fill up. You will want to keep an eye on that, and maybe add more workers, or have some other strategy.</p>
<p>如果所有的工作者都繁忙，那么你的队列会被填满。你需要注意这种情况，要么添加多几个工作者，要么就采用其它策略。</p>
</blockquote>
<p>By using spring-amqp you get reasonable values configured for message acknowledgments and fair dispatching. The default durability for queues and persistence for messages provided by spring-amqp allow let the messages to survive even if RabbitMQ is restarted.</p>
<p>通过使用spring-amqp，你会发现，它已经为消息确认和公平调度配置好合理值。spring-amqp为队列和消息持久化提供的默认持久属性使得即使在RabbitMQ重启的情况下，消息还能保存下来。</p>
<p>For more information on Channel methods and MessageProperties, you can browse the <a href="http://docs.spring.io/spring-amqp/docs/current/api/index.html?org/springframework/amqp/package-summary.html">javadocs online</a>. For understanding the underlying foundation for spring-amqp you can find the <a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/">rabbitmq-java-client</a>.</p>
<p>关于channel方法和MessageProperties的更多信息，可以浏览<a href="http://docs.spring.io/spring-amqp/docs/current/api/index.html?org/springframework/amqp/package-summary.html">在线的javadocs</a>。若要了解spring-amqp的底层机制，可以参阅<a href="https://rabbitmq.github.io/rabbitmq-java-client/api/current/">rabbitmq-java-client文档</a>。</p>
<p>Now we can move on to tutorial 3 and learn how to deliver the same message to many consumers.</p>
<p>现在我们可以开始教程3，学习如何将相同的消息发送给多个消费者。</p>
]]></content>
      <categories>
        <category>RabbitMQ Spring-AMQP官方教程</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>4、代码审查内容</title>
    <url>/posts/16518/</url>
    <content><![CDATA[<p>Note: Always make sure to take into account <a href="../51044">The Standard of Code Review</a> when considering each of these points.<br />
注意：在审查下面这几点时，请确保也将<a href="../51044">代码审查标准</a>考虑了进去。</p>
<span id="more"></span>
<h2 id="design设计"><a class="markdownIt-Anchor" href="#design设计"></a> Design（设计）</h2>
<p>The most important thing to cover in a review is the overall design of the CL. Do the interactions of various pieces of code in the CL make sense? Does this change belong in your codebase, or in a library? Does it integrate well with the rest of your system? Is now a good time to add this functionality?<br />
代码评审时最重要的一个地方就是该次代码变更的整体设计。该次代码变更的各个代码片段之间的交互是否有意义？该次变更是属于代码库的变更还是属于使用的库的变更？提审的代码是否能与系统的其它部分很好的集成起来？现在是否适合添加这个功能？</p>
<h2 id="functionality功能"><a class="markdownIt-Anchor" href="#functionality功能"></a> Functionality（功能）</h2>
<p>Does this CL do what the developer intended? Is what the developer intended good for the users of this code? The “users” are usually both end-users (when they are affected by the change) and developers (who will have to “use” this code in the future).<br />
该次代码变更是否达到了开发人员想要的效果？开发人员想要达到的效果是否能满足用户？注意，此处的“用户”不仅是指受本次变更影响的终端用户，也指后面会使用这段代码的开发人员。</p>
<p>Mostly, we expect developers to test CLs well-enough that they work correctly by the time they get to code review. However, as the reviewer you should still be thinking about edge cases, looking for concurrency problems, trying to think like a user, and making sure that there are no bugs that you see just by reading the code.<br />
多数情况下，我们希望开发人员在提交代码审核前能对要代码做足够的测试。然而，作为评审人，你仍需考虑边界情况、看下是否有并发问题、试着从用户的角度去思考，以此来确保不会存在那种仅通过阅读代码就能发现的bug。</p>
<p>You <em>can</em> validate the CL if you want—the time when it’s most important for a reviewer to check a CL’s behavior is when it has a user-facing impact, such as a <strong>UI change</strong>. It’s hard to understand how some changes will impact a user when you’re just reading the code. For changes like that, you can have the developer give you a demo of the functionality if it’s too inconvenient to patch in the CL and try it yourself.<br />
如果有需要，评审人也可以去验证提交上来的代码的正确性，如果某次提审的代码变更涉及到影响用户的直观体验（例如UI变了），那么此时评审人去检查该部分的代码是很重要的。如果只是去阅读这些代码，评审人很难想象这些变更会对用户造成什么样的影响。对于这类变更，如果评审人不方便在提审的代码变更里自己做测试，可以让开发人员给一个该功能的样例。</p>
<p>Another time when it’s particularly important to think about functionality during a code review is if there is some sort of <strong>parallel programming</strong> going on in the CL that could theoretically cause deadlocks or race conditions. These sorts of issues are very hard to detect by just running the code and usually need somebody (both the developer and the reviewer) to think through them carefully to be sure that problems aren’t being introduced. (Note that this is also a good reason not to use concurrency models where race conditions or deadlocks are possible—it can make it very complex to do code reviews or understand the code.)<br />
另一个在代码评审时需要重点关注的地方是，提审的代码里是否包含着并发编程，因为这部分代码理论上会引发死锁或者资源竞争问题。这类问题很难通过运行代码被发现，通常需要开发人员和评审人员一起仔细甄别来防止这些问题的出现。（这也是不使用可能引发资源竞争或者死锁问题的并发模型的一个好理由，毕竟这部分代码审核起来比较麻烦而且不容易理解。）</p>
<h2 id="complexity复杂性"><a class="markdownIt-Anchor" href="#complexity复杂性"></a> Complexity（复杂性）</h2>
<p>Is the CL more complex than it should be? Check this at every level of the CL—are individual lines too complex? Are functions too complex? Are classes too complex? “Too complex” usually means <strong>“can’t be understood quickly by code readers.”</strong> It can also mean <strong>“developers are likely to introduce bugs when they try to call or modify this code.”</strong><br />
该次代码变更是否过于复杂了？可以从不同层面去对其进行检查：某些代码行是不是太复杂了？某些函数是不是太复杂了？某些类是不是太复杂了？这里的“太复杂”的定义通常是：<strong>无法被阅读代码的人快速理解。</strong> 它也可以定义为：<strong>开发人员如果尝试调用或者修改该代码，将很容易引入bug。</strong></p>
<p>A particular type of complexity is <strong>over-engineering</strong>, where developers have made the code more generic than it needs to be, or added functionality that isn’t presently needed by the system. Reviewers should be especially vigilant about over-engineering. Encourage developers to solve the problem they know needs to be solved <em>now</em>, not the problem that the developer speculates <em>might</em><br />
need to be solved in the future. The future problem should be solved once it arrives and you can see its actual shape and requirements in the physical universe.<br />
有个比较特殊的复杂场景，那就是<strong>过度设计</strong>，意思是开发人员写的代码过于通用化了，或者为系统添加了当前不需要的功能。评审人员应该要特别警惕过度设计。鼓励开发人员解决他们<strong>当前</strong>需要解决的问题，而不是去解决那些推测未来<strong>可能</strong>需要解决的问题。只有当这些未来的问题到来了，并且能看到具体的内容及需求了，我们才应该立马去解决。</p>
<h2 id="tests测试"><a class="markdownIt-Anchor" href="#tests测试"></a> Tests（测试）</h2>
<p>Ask for unit, integration, or end-to-end<br />
tests as appropriate for the change. In general, tests should be added in the same CL as the production code unless the CL is handling an <a href="../emergencies.md">emergency</a>.<br />
检查开发人员是否已为该次代码变更做了相应的单元测试、集成测试或者端到端测试。通常情况下，测试应该被加入到变更记录里作为产品代码的一部分，除非这个变更是为了处理某次<a href="../">紧急情况</a></p>
<p>Make sure that the tests in the CL are correct, sensible, and useful. Tests do not test themselves, and we rarely write tests for our tests—a human must ensure that tests are valid.<br />
确保代码变更里的的测试是正确的，有意义的，而且是有用的。测试代码本身不会保证其自身是有效的，而且我们也不会去编写测试代码的测试代码，所以我们需要保证测试是有效的。</p>
<p>Will the tests actually fail when the code is broken? If the code changes beneath them, will they start producing false positives? Does each test make simple and useful assertions? Are the tests separated appropriately between different test methods?<br />
当生产代码发生变更时，这些测试代码是否还能运行？这些测试代码发生变更时，是否会产生误报？每个测试是否都做了简单但有用的断言（assertions）？测试案例是否恰当地分开在不同的方法里了？</p>
<p>Remember that tests are also code that has to be maintained. Don’t accept complexity in tests just because they aren’t part of the main binary.<br />
记住，测试也是必须要维护的代码，不能因为它们不属于最终的运行程序包一部分而允许测试代码写的很复杂。</p>
<h2 id="naming命名"><a class="markdownIt-Anchor" href="#naming命名"></a> Naming（命名）</h2>
<p>Did the developer pick good names for everything? A good name is long enough to fully communicate what the item is or does, without being so long that it becomes hard to read.<br />
开发人员是否为每一处需要命名的地方都选取了好的命名？一个好的命名会长度适中，充分表达该条目是什么或者是做什么的，同时也不会因为过长而变得难以阅读。</p>
<h2 id="comments注释"><a class="markdownIt-Anchor" href="#comments注释"></a> Comments（注释）</h2>
<p>Did the developer write clear comments in understandable English? Are all of the comments actually necessary? Usually comments are useful when they <strong>explain why</strong> some code exists, and should not be explaining <em>what</em> some code is doing. If the code isn’t clear enough to explain itself, then the code should be made simpler. There are some exceptions (regular expressions and complex algorithms often benefit greatly from comments that explain what they’re doing, for example) but mostly comments are for information that the code itself can’t possibly contain, like the reasoning behind a decision.<br />
开发人员是否为代码写了清晰的注释？是否所有的注释都是必须的？通常情况下，当一段注释是来<strong>解释为什么</strong>这部分代码需要存在时，那么这段注释就是有用的，而且不应该去解释这部分代码在<em>做什么</em>。如果某段代码无法足够清晰的去进行自解释，那么这段代码就应该写得更简单点。也有些例外的情况（例如，对于正则表达式和复杂的算法，如果有注释来说明这些代码在做什么，将会很有用），但多数情况下，注释是用来标注代码本身无法包含的东西，譬如代码决定这么写的原因。</p>
<p>It can also be helpful to look at comments that were there before this CL. Maybe there is a TODO that can be removed now, a comment advising against this change being made, etc.<br />
有时也可以看下代码里现有的注释。可能有个现在可以移除的TODO，有条建议不要进行此变更的注释，等等。</p>
<p>Note that comments are different from <em>documentation</em> of classes, modules, or functions, which should instead express the purpose of a piece of code, how it should be used, and how it behaves when used.<br />
注意，注释不同于类、模块或者函数的<em>文档</em>，文档应该表述某个代码片段的目的，该代码片段如何使用，以及使用该代码片段时会有什么样的行为。</p>
<h2 id="style代码规范"><a class="markdownIt-Anchor" href="#style代码规范"></a> Style（代码规范）</h2>
<p>We have <a href="http://google.github.io/styleguide/">style guides</a> at Google for all of our major languages, and even for most of the minor languages. Make sure the CL follows the appropriate style guides.<br />
在Google内部，我们为所用到的所有主流语言甚至是多数非主流语言都制定了相应的<a href="http://google.github.io/styleguide/">规范规约</a>。要确保该次代码变更遵从了恰当的代码规范规约。</p>
<p>If you want to improve some style point that isn’t in the style guide, prefix your comment with “Nit:” to let the developer know that it’s a nitpick that you think would improve the code but isn’t mandatory. Don’t block CLs from being submitted based only on personal style preferences.<br />
如果你想改善某些不在规约规范里的点，那么在留言评论时可以在前面加上“Nit：”，以此来让开发人员知道这个只是你个人认为的可以改进的地方，而不是强制性的。不能仅因为个人的规范风格喜好的原因而阻断了代码变更的提交通过。</p>
<p>The author of the CL should not include major style changes combined with other changes. It makes it hard to see what is being changed in the CL, makes merges and rollbacks more complex, and causes other problems. For example, if the author wants to reformat the whole file, have them send you just the reformatting as one CL, and then send another CL with their functional changes after that.<br />
代码变更的作者不应将主要内容为规范变更的代码与其他变更代码混合在一起。这么做会让人难以看出该次代码变更的变更内容是什么，还会使合并和回滚变得复杂，并且引发别的问题。举个例子，如果作者想格式化整个文件，那么应该把格式化作为一次变更提交，然后再将功能性的变更作为一次变更提交。</p>
<h2 id="consistency一致性"><a class="markdownIt-Anchor" href="#consistency一致性"></a> Consistency（一致性）</h2>
<p>What if the existing code is inconsistent with the style guide? Per our <a href="../51044#principles">code review principles</a>, the style guide is the absolute authority: if something is required by the style guide, the CL should follow the guidelines.<br />
如果现有的代码与规范规约不一致怎么办？根据我们的<a href="../51044#principles">代码审查原则</a>，规范规约是绝对的权威：如果是规范规约所要求的，那么代码变更就应该遵从。</p>
<p>In some cases, the style guide makes recommendations rather than declaring requirements. In these cases, it’s a judgment call whether the new code should be consistent with the recommendations or the surrounding code. Bias towards following the style guide unless the local inconsistency would be too confusing.<br />
在某些情况下，规范规约只是做出了推荐做法而不是做强制要求。在这些情况下，需要判断新代码是否要与推荐做法或者现有其它代码保持一致。如果这个不一致性争议性较强，则应该遵从规范规约。</p>
<p>If no other rule applies, the author should maintain consistency with the existing code. Either way, encourage the author to file a bug and add a TODO for cleaning up existing code.<br />
如果没有其它适用规则，那么作者应该与现有代码保持一致。无论是哪种方式，都应鼓励作者记录下问题并添加一个TODO，以此来清理现有代码。</p>
<h2 id="documentation文档"><a class="markdownIt-Anchor" href="#documentation文档"></a> Documentation（文档）</h2>
<p>If a CL changes how users build, test, interact with, or release code, check to see that it also updates associated documentation, including READMEs, g3doc pages, and any generated reference docs. If the CL deletes or deprecates code, consider whether the documentation should also be deleted. If documentation is missing, ask for it.<br />
如果某次代码变更改变了用户构建、测试、交互或者发布代码的方式，那么审查人员也要检查是否同步更新了相关的文档，包括README文档、g3doc页面（g3doc为google内部的文档管理平台）以及任何生成的参考文档。如果该次代码变更删除或者弃用了某些代码，则还要看对应的文档是否也删除了。如果缺失了文档，则应要求作者去补充。</p>
<h2 id="every-line每一行"><a class="markdownIt-Anchor" href="#every-line每一行"></a> Every Line（每一行）</h2>
<p>In the general case, look at <em>every</em> line of code that you have been assigned to review. Some things like data files, generated code, or large data structures you can scan over sometimes, but don’t scan over a human-written class, function, or block of code and assume that what’s inside of it is okay. Obviously some code deserves more careful scrutiny than other code—that’s a judgment call that you have to make—but you should at least be sure that you <em>understand</em> what all the code is doing.<br />
一般情况下，审查人员需要审查<em>每</em>一行提交上来的代码。对于诸如数据文件、自动生成的代码，或者大型的数据结构，审查人员可以另外找个时间再来进行扫视，但对于手写的类、函数或者代码块，则不能假设这里面是没问题然后只是简单的一扫而过。（对于要审查的代码）有些代码比其它代码更值得审阅，这是审查人员必须要做的判断，但是审查人员至少要确保<em>理解</em>这些代码都实现了什么功能行为。</p>
<p>If it’s too hard for you to read the code and this is slowing down the review, then you should let the developer know that and wait for them to clarify it before you try to review it. At Google, we hire great software engineers, and you are one of them. If you can’t understand the code, it’s very likely that other developers won’t either. So you’re also helping future developers understand this code, when you ask the developer to clarify it.<br />
审查人员在审查过程中如果发觉阅读这些代码很困难，并且使得审查进度慢了下来，那么审查人员应该让开发人员知道这点，等开发人员解释说明清楚后再去审查。在Google，我们雇佣了很多很棒的软件工程师，而审查人员也是他们中的一员。如果审查人员无法理解某段代码，那么其他的工程师也很可能无法理解。所以，当审查人员在让开发人员解释说明某段代码时，也是在帮助以后的开发人员理解这段代码。</p>
<p>If you understand the code but you don’t feel qualified to do some part of the review, <a href="#exceptions-every-line-exceptions">make sure there is a reviewer</a> on the CL who is qualified, particularly for complex issues such as privacy, security, concurrency, accessibility, internationalization, etc.<br />
如果你理解该部分代码但是又觉得好像不够资格来去做这部分代码审查，那么要确保能有个足够资格的人来去审核它，尤其是面对诸如隐私，安全，并发，可访问性，国际化等复杂问题时。</p>
<h3 id="exceptions例外情况"><a class="markdownIt-Anchor" href="#exceptions例外情况"></a> Exceptions（例外情况）</h3>
<p>What if it doesn’t make sense for you to review every line? For example, you are one of multiple reviewers on a CL and may be asked:<br />
如果审查每一行对你来说没有意义怎么办？例如，你是评审人之一然后可能会被要求：</p>
<ul>
<li>To review only certain files that are part of a larger change.</li>
<li>对于某次大的变更提交，你只需审查某些指定的文件。</li>
<li>To review only certain aspects of the CL, such as the high-level design, privacy or security implications, etc.</li>
<li>只需审查该次变更提交的某些层面，例如高层次的设计，隐私或者安全影响等。</li>
</ul>
<p>In these cases, note in a comment which parts you reviewed. Prefer giving <a href="speed.md#lgtm-with-comments">LGTM with comments</a>.<br />
在这些场景下，在评论里标注你审核了哪些内容。建议可以在评论里给一个“LGTM”（Look Good To Me的缩写，对应到Gerrit就是+1）。</p>
<p>If you instead wish to grant LGTM after confirming that other reviewers have reviewed other parts of the CL, note this explicitly in a comment to set expectations. Aim to <a href="speed.md#responses">respond quickly</a> once the CL has reached the desired state.<br />
如果在确认其他审查人员已经审查了其它部分的情况下，你仍然希望给一个LGTM，那么请在评论里明确写下你的期望建议。目的是为了当有代码变更提交上来时，能做到快速响应。</p>
<h2 id="context上下文"><a class="markdownIt-Anchor" href="#context上下文"></a> Context（上下文）</h2>
<p>It is often helpful to look at the CL in a broad context. Usually the code review tool will only show you a few lines of code around the parts that are being changed. Sometimes you have to look at the whole file to be sure that the change actually makes sense. For example, you might see only four new lines being added, but when you look at the whole file, you see those four lines are in a 50-line method that now really needs to be broken up into smaller methods.<br />
看一下当前代码变更的上下文对于代码审查会很有帮助。通常情况下，代码审查工具只会展示变更了的那几行代码。有时你需要看下整个文件来确保该次变更是有意义的。例如，在看上下文之前，你可能会觉得就只是加了4行新代码而已，但如果你看下整个文件，你会发现这4行代码是包含在一个50行代码的函数里的，这时候这个函数就必须分割成几个更小的函数了。</p>
<p>It’s also useful to think about the CL in the context of the system as a whole. Is this CL improving the code health of the system or is it making the whole system more complex, less tested, etc.? <strong>Don’t accept CLs that degrade the code health of the system.</strong> Most systems become complex through many small changes that add up, so it’s important to prevent even small complexities in new changes.<br />
基于整个系统上下文来去审查代码也是很有用的。该次代码变更是否提高了系统代码质量？还是说使得整个系统变得更复杂了，测试覆盖率变低了？<strong>不能让降低了系统代码质量的代码提交通过。</strong> 大多数系统都是随着变更的不断提交而变得复杂起来，所以我们应该在每一个新的提交里都去防止哪怕很小的复杂性的出现，这一点是很重要的。</p>
<h2 id="good-things好的地方"><a class="markdownIt-Anchor" href="#good-things好的地方"></a> Good Things（好的地方）</h2>
<p>If you see something nice in the CL, tell the developer, especially when they addressed one of your comments in a great way. Code reviews often just focus on mistakes, but they should offer encouragement and appreciation for good practices, as well. It’s sometimes even more valuable, in terms of mentoring, to tell a developer what they did right than to tell them what they did wrong.<br />
如果你在变更集里看到了好的实践，那么请告诉相应的开发人员，特别是当他们针对你的评注以不错的方式进行了处理。代码评审通常会专注于错误的提出，但同时也应该鼓励赞美好的实践。有时告诉开发人员做对了什么比告诉他们做错了什么更有指导意义。</p>
<h2 id="summary总结"><a class="markdownIt-Anchor" href="#summary总结"></a> Summary（总结）</h2>
<p>In doing a code review, you should make sure that:</p>
<ul>
<li>The code is well-designed.</li>
<li>The functionality is good for the users of the code.</li>
<li>Any UI changes are sensible and look good.</li>
<li>Any parallel programming is done safely.</li>
<li>The code isn’t more complex than it needs to be.</li>
<li>The developer isn’t implementing things they <em>might</em> need in the future but don’t know they need now.</li>
<li>Code has appropriate unit tests.</li>
<li>Tests are well-designed.</li>
<li>The developer used clear names for everything.</li>
<li>Comments are clear and useful, and mostly explain <em>why</em> instead of <em>what</em>.</li>
<li>Code is appropriately documented (generally in g3doc).</li>
<li>The code conforms to our style guides.</li>
</ul>
<p>在做代码审查时，应该审查以下几点：</p>
<ul>
<li>代码是设计良好的。</li>
<li>用户（包括终端用户和使用这部分代码的开发人员）是可以放心使用这部分功能的。</li>
<li>任何UI上的改动都是有意义的并且看起来还不错。</li>
<li>所有的多线程编程都应该是安全的。</li>
<li>代码已经足够简洁。</li>
<li>不会过度设计，不会实现还用不到的功能。</li>
<li>代码里包含着恰当的单元测试。</li>
<li>测试代码也是设计良好的。</li>
<li>代码里所有用到的命名都做到了见名知意。</li>
<li>注释是清晰而且有用的，同时主要是解释了“为什么”而不是“什么”。</li>
<li>代码有恰当的文档。</li>
<li>代码符合我们的开发规范。</li>
</ul>
<p>Make sure to review <strong>every line</strong> of code you’ve been asked to review, look at the <strong>context</strong>, make sure you’re <strong>improving code health</strong>, and compliment developers on <strong>good things</strong> that they do.<br />
当你被指定去审核代码时，要切实审查了每一行代码，看看<strong>上下文</strong>，确保你是在帮助<strong>提高代码质量</strong>，同时对于开发人员做得好的地方，还要对其进行表扬。</p>
<p>Next: <a href="navigate.md">Navigating a CL in Review</a></p>
]]></content>
      <categories>
        <category>Google代码评审规约</category>
      </categories>
      <tags>
        <tag>Translation</tag>
        <tag>Code Review</tag>
      </tags>
  </entry>
</search>
